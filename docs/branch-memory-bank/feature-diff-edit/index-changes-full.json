{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "index-changes-full",
    "title": "index.tsファイルの完全な変更計画",
    "documentType": "plan",
    "path": "index-changes-full.json",
    "tags": [
      "json-patch",
      "implementation",
      "memory-bank"
    ],
    "lastModified": "2025-03-24T23:00:00.000Z",
    "createdAt": "2025-03-24T23:00:00.000Z",
    "version": 1
  },
  "content": {
    "changes": [
      {
        "location": "AVAILABLE_TOOLS - write_branch_memory_bank",
        "description": "パッチ操作をサポートするための入力スキーマの拡張",
        "current": "inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        content: { type: 'string' },\n        branch: {\n          type: 'string',\n          description: 'Branch name',\n        },\n        workspace: {\n          type: 'string',\n          description: 'Path to workspace directory',\n        },\n        docs: {\n          type: 'string',\n          description: 'Path to docs directory',\n        },\n      },\n      required: ['path', 'branch'],\n    },",
        "updated": "inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        content: { type: 'string' },\n        patches: {\n          type: 'array',\n          description: 'JSON Patch operations to apply (RFC 6902)',\n          items: {\n            type: 'object',\n            properties: {\n              op: {\n                type: 'string',\n                enum: ['add', 'remove', 'replace', 'move', 'copy', 'test'],\n                description: 'Operation type'\n              },\n              path: {\n                type: 'string',\n                description: 'JSON Pointer path (e.g. /metadata/title)'\n              },\n              value: {\n                description: 'Value for add, replace, test operations'\n              },\n              from: {\n                type: 'string',\n                description: 'Source path for move, copy operations'\n              }\n            },\n            required: ['op', 'path']\n          }\n        },\n        branch: {\n          type: 'string',\n          description: 'Branch name',\n        },\n        workspace: {\n          type: 'string',\n          description: 'Path to workspace directory',\n        },\n        docs: {\n          type: 'string',\n          description: 'Path to docs directory',\n        },\n      },\n      required: ['path', 'branch'],\n    },"
      },
      {
        "location": "AVAILABLE_TOOLS - write_global_memory_bank",
        "description": "同様にパッチ操作をサポートするための入力スキーマの拡張",
        "current": "inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        content: { type: 'string' },\n        workspace: {\n          type: 'string',\n          description: 'Path to workspace directory',\n        },\n        docs: {\n          type: 'string',\n          description: 'Path to docs directory',\n        },\n      },\n      required: ['path'],\n    },",
        "updated": "inputSchema: {\n      type: 'object',\n      properties: {\n        path: { type: 'string' },\n        content: { type: 'string' },\n        patches: {\n          type: 'array',\n          description: 'JSON Patch operations to apply (RFC 6902)',\n          items: {\n            type: 'object',\n            properties: {\n              op: {\n                type: 'string',\n                enum: ['add', 'remove', 'replace', 'move', 'copy', 'test'],\n                description: 'Operation type'\n              },\n              path: {\n                type: 'string',\n                description: 'JSON Pointer path (e.g. /metadata/title)'\n              },\n              value: {\n                description: 'Value for add, replace, test operations'\n              },\n              from: {\n                type: 'string',\n                description: 'Source path for move, copy operations'\n              }\n            },\n            required: ['op', 'path']\n          }\n        },\n        workspace: {\n          type: 'string',\n          description: 'Path to workspace directory',\n        },\n        docs: {\n          type: 'string',\n          description: 'Path to docs directory',\n        },\n      },\n      required: ['path'],\n    },"
      },
      {
        "location": "write_branch_memory_bank case handler",
        "description": "write_branch_memory_bankのケースハンドラにパッチ処理ロジックを追加",
        "current": "    case 'write_branch_memory_bank': {\n      const path = params.path as string;\n      const content = params.content as string | undefined;\n      const branch = params.branch as string;\n      const workspace = params.workspace as string | undefined;\n      const docs = params.docs as string | undefined;\n\n      if (!path || !branch) {\n        throw new Error('Invalid arguments for write_branch_memory_bank: path and branch are required');\n      }\n\n      if (!content) {\n        return { content: [{ type: 'text', text: 'Branch memory bank initialized successfully' }] };\n      }\n\n      if (!app) {\n        throw new Error('Application not initialized');\n      }\n\n      // Resolve workspace and docs directories\n      const paths = resolveWorkspaceAndDocs(workspace, docs);\n      logger.debug(`Writing branch memory bank (branch: ${branch}, path: ${path}, workspace: ${paths.workspace})`);\n\n      // Create a new application instance if needed\n      let branchApp = app;\n      if (workspace || docs) {\n        logger.debug(`Creating new application instance with workspace: ${paths.workspace}, docs: ${paths.docs}`);\n        branchApp = await createApplication({\n          workspace: paths.workspace,\n          memoryRoot: paths.docs,\n          language: 'ja',\n          verbose: false,\n        });\n      }\n\n      // Try to write the document and check the result\n      const response = await branchApp.getBranchController().writeDocument(branch, path, content);\n      if (!response.success) {\n        throw new Error((response as any).error?.message || 'Failed to write document');\n      }\n\n      return { content: [{ type: 'text', text: 'Document written successfully' }] };\n    }",
        "updated": "    case 'write_branch_memory_bank': {\n      const path = params.path as string;\n      const content = params.content as string | undefined;\n      const patches = params.patches as any[] | undefined;\n      const branch = params.branch as string;\n      const workspace = params.workspace as string | undefined;\n      const docs = params.docs as string | undefined;\n\n      if (!path || !branch) {\n        throw new Error('Invalid arguments for write_branch_memory_bank: path and branch are required');\n      }\n\n      // Content and patches cannot be provided at the same time\n      if (content && patches) {\n        throw new Error('Content and patches cannot be provided at the same time');\n      }\n\n      // Initialize a new branch without content\n      if (!content && !patches) {\n        return { content: [{ type: 'text', text: 'Branch memory bank initialized successfully' }] };\n      }\n\n      if (!app) {\n        throw new Error('Application not initialized');\n      }\n\n      // Resolve workspace and docs directories\n      const paths = resolveWorkspaceAndDocs(workspace, docs);\n\n      // Create a new application instance if needed\n      let branchApp = app;\n      if (workspace || docs) {\n        logger.debug(`Creating new application instance with workspace: ${paths.workspace}, docs: ${paths.docs}`);\n        branchApp = await createApplication({\n          workspace: paths.workspace,\n          memoryRoot: paths.docs,\n          language: 'ja',\n          verbose: false,\n        });\n      }\n\n      // Case 1: Content provided - use normal write operation\n      if (content) {\n        logger.debug(`Writing branch memory bank (branch: ${branch}, path: ${path}, workspace: ${paths.workspace})`);\n        const response = await branchApp.getBranchController().writeDocument(branch, path, content);\n        if (!response.success) {\n          throw new Error((response as any).error?.message || 'Failed to write document');\n        }\n        return { content: [{ type: 'text', text: 'Document written successfully' }] };\n      }\n\n      // Case 2: Patches provided - apply JSON Patch operations\n      if (patches) {\n        logger.debug(`Applying patches to branch memory bank (branch: ${branch}, path: ${path}, workspace: ${paths.workspace})`);\n        \n        try {\n          // Import necessary classes\n          const { JsonPatchOperation } = await import('./domain/jsonpatch/JsonPatchOperation.js');\n          const { FastJsonPatchAdapter } = await import('./domain/jsonpatch/FastJsonPatchAdapter.js');\n\n          // Create adapter for patch application\n          const patchService = new FastJsonPatchAdapter();\n\n          // First, read the document\n          const readResult = await branchApp.getBranchController().readDocument(branch, path);\n          if (!readResult.success) {\n            throw new Error(`Document not found: ${path} in branch ${branch}. Create the document first before applying patches.`);\n          }\n\n          const document = readResult.data?.content;\n          if (!document) {\n            throw new Error(`Document is empty or invalid: ${path} in branch ${branch}`);\n          }\n\n          // Parse document content to JSON if it's a string\n          const docContent = typeof document === 'string' ? JSON.parse(document) : document;\n\n          // Convert patch operations to domain model\n          const patchOperations = patches.map(patch => {\n            return JsonPatchOperation.create(\n              patch.op,\n              patch.path,\n              patch.value,\n              patch.from\n            );\n          });\n\n          // Apply patches\n          logger.debug(`Applying ${patchOperations.length} JSON Patch operations`);\n          \n          // Execute validation\n          const isValid = patchService.validate(docContent, patchOperations);\n          if (!isValid) {\n            throw new Error('Invalid JSON Patch operations');\n          }\n\n          // Apply patches\n          const updatedContent = patchService.apply(docContent, patchOperations);\n          \n          // Save the updated document\n          const jsonString = JSON.stringify(updatedContent, null, 2);\n          const writeResult = await branchApp.getBranchController().writeDocument(branch, path, jsonString);\n          \n          if (!writeResult.success) {\n            throw new Error((writeResult as any).error?.message || 'Failed to save patched document');\n          }\n          \n          return { content: [{ type: 'text', text: 'Document patched successfully' }] };\n        } catch (error) {\n          logger.error('Error applying JSON Patch:', error);\n          throw error instanceof Error ? error : new Error(String(error));\n        }\n      }\n      \n      // Should never reach here\n      throw new Error('Invalid state: neither content nor patches were provided');\n    }"
      },
      {
        "location": "write_global_memory_bank case handler",
        "description": "write_global_memory_bankのケースハンドラにパッチ処理ロジックを追加",
        "current": "    case 'write_global_memory_bank': {\n      const path = params.path as string;\n      const content = params.content as string | undefined;\n      const workspace = params.workspace as string | undefined;\n      const docs = params.docs as string | undefined;\n\n      if (!path) {\n        throw new Error('Invalid arguments for write_global_memory_bank');\n      }\n\n      if (!content) {\n        return { content: [{ type: 'text', text: 'Global memory bank initialized successfully' }] };\n      }\n\n      if (!app) {\n        throw new Error('Application not initialized');\n      }\n\n      // Resolve workspace and docs directories\n      const paths = resolveWorkspaceAndDocs(workspace, docs);\n      logger.debug(`Writing global memory bank (path: ${path}, workspace: ${paths.workspace})`);\n\n      // Create a new application instance if needed\n      let globalApp = app;\n      if (workspace || docs) {\n        logger.debug(`Creating new application instance with workspace: ${paths.workspace}, docs: ${paths.docs}`);\n        globalApp = await createApplication({\n          workspace: paths.workspace,\n          memoryRoot: paths.docs,\n          language: 'ja',\n          verbose: false,\n        });\n      }\n\n      // Try to write the document and check the result\n      const response = await globalApp.getGlobalController().writeDocument(path, content);\n      if (!response.success) {\n        throw new Error((response as any).error?.message || 'Failed to write document');\n      }\n\n      return { content: [{ type: 'text', text: 'Document written successfully' }] };\n    }",
        "updated": "    case 'write_global_memory_bank': {\n      const path = params.path as string;\n      const content = params.content as string | undefined;\n      const patches = params.patches as any[] | undefined;\n      const workspace = params.workspace as string | undefined;\n      const docs = params.docs as string | undefined;\n\n      if (!path) {\n        throw new Error('Invalid arguments for write_global_memory_bank');\n      }\n\n      // Content and patches cannot be provided at the same time\n      if (content && patches) {\n        throw new Error('Content and patches cannot be provided at the same time');\n      }\n\n      // Initialize a new document without content\n      if (!content && !patches) {\n        return { content: [{ type: 'text', text: 'Global memory bank initialized successfully' }] };\n      }\n\n      if (!app) {\n        throw new Error('Application not initialized');\n      }\n\n      // Resolve workspace and docs directories\n      const paths = resolveWorkspaceAndDocs(workspace, docs);\n\n      // Create a new application instance if needed\n      let globalApp = app;\n      if (workspace || docs) {\n        logger.debug(`Creating new application instance with workspace: ${paths.workspace}, docs: ${paths.docs}`);\n        globalApp = await createApplication({\n          workspace: paths.workspace,\n          memoryRoot: paths.docs,\n          language: 'ja',\n          verbose: false,\n        });\n      }\n\n      // Case 1: Content provided - use normal write operation\n      if (content) {\n        logger.debug(`Writing global memory bank (path: ${path}, workspace: ${paths.workspace})`);\n        const response = await globalApp.getGlobalController().writeDocument(path, content);\n        if (!response.success) {\n          throw new Error((response as any).error?.message || 'Failed to write document');\n        }\n        return { content: [{ type: 'text', text: 'Document written successfully' }] };\n      }\n\n      // Case 2: Patches provided - apply JSON Patch operations\n      if (patches) {\n        logger.debug(`Applying patches to global memory bank (path: ${path}, workspace: ${paths.workspace})`);\n        \n        try {\n          // Import necessary classes\n          const { JsonPatchOperation } = await import('./domain/jsonpatch/JsonPatchOperation.js');\n          const { FastJsonPatchAdapter } = await import('./domain/jsonpatch/FastJsonPatchAdapter.js');\n\n          // Create adapter for patch application\n          const patchService = new FastJsonPatchAdapter();\n\n          // First, read the document\n          const readResult = await globalApp.getGlobalController().readDocument(path);\n          if (!readResult.success) {\n            throw new Error(`Document not found: ${path}. Create the document first before applying patches.`);\n          }\n\n          const document = readResult.data?.content;\n          if (!document) {\n            throw new Error(`Document is empty or invalid: ${path}`);\n          }\n\n          // Parse document content to JSON if it's a string\n          const docContent = typeof document === 'string' ? JSON.parse(document) : document;\n\n          // Convert patch operations to domain model\n          const patchOperations = patches.map(patch => {\n            return JsonPatchOperation.create(\n              patch.op,\n              patch.path,\n              patch.value,\n              patch.from\n            );\n          });\n\n          // Apply patches\n          logger.debug(`Applying ${patchOperations.length} JSON Patch operations`);\n          \n          // Execute validation\n          const isValid = patchService.validate(docContent, patchOperations);\n          if (!isValid) {\n            throw new Error('Invalid JSON Patch operations');\n          }\n\n          // Apply patches\n          const updatedContent = patchService.apply(docContent, patchOperations);\n          \n          // Save the updated document\n          const jsonString = JSON.stringify(updatedContent, null, 2);\n          const writeResult = await globalApp.getGlobalController().writeDocument(path, jsonString);\n          \n          if (!writeResult.success) {\n            throw new Error((writeResult as any).error?.message || 'Failed to save patched document');\n          }\n          \n          return { content: [{ type: 'text', text: 'Document patched successfully' }] };\n        } catch (error) {\n          logger.error('Error applying JSON Patch:', error);\n          throw error instanceof Error ? error : new Error(String(error));\n        }\n      }\n      \n      // Should never reach here\n      throw new Error('Invalid state: neither content nor patches were provided');\n    }"
      }
    ]
  }
}