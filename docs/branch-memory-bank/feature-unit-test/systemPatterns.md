# システムパターン

## 技術的決定事項

### DTOプロパティの厳格な定義

#### コンテキスト
データ転送オブジェクト（DTO）の定義と実際の使用において整合性が必要

#### 決定事項
DTOインターフェースに明示されていないプロパティはテストや実装で使用しない

#### 影響
- 型エラーの早期発見
- リファクタリング時の変更箇所の特定が容易になる
- APIの一貫性が保たれる

### テストコードでのモックオブジェクト定義

#### コンテキスト
テスト対象のクラスが依存するインターフェースをモック化する必要がある

#### 決定事項
jestのモック機能を使い、インターフェースに完全に一致したモックオブジェクトを作成する

#### 影響
- 型安全性が確保される
- インターフェースの変更時にテストコードでも修正が必要という早期警告が得られる
- テストの堅牢性が向上する

### ES Moduleインポート時の拡張子指定

#### コンテキスト
TypeScriptのモジュール解決方式として、Node16またはNodeNextを使用している場合、相対パスのインポートには明示的な拡張子が必要

#### 決定事項
すべてのインポートに.js拡張子を明示的に追加する

#### 影響
- コンパイル時のモジュール解決エラーを防止できる
- ESモジュールとの互換性が高まる
- IDEの自動インポートが適切に機能する

### テストカバレッジ目標

#### コンテキスト
プロジェクトのコード品質を確保するためにテストカバレッジの目標設定が必要です。

#### 決定事項
コア機能（特にドメインとアプリケーションレイヤー）は80%以上のカバレッジを目指します。初期段階では70%を目標とし、徐々に向上させていきます。

#### 影響
- コア機能の信頼性が高まる
- リグレッションの早期発見が可能になる
- 継続的なカバレッジ改善のモチベーションになる

### モックとスタブの利用戦略

#### コンテキスト
外部依存性を持つコンポーネントのテスト方法を決定する必要があります。

#### 決定事項
依存性は適切にモック化し、テスト対象を分離します。Jestのjest.fn()、jest.mock()機能を活用します。

#### 影響
- テスト実行が高速化
- テスト対象を分離して単体でテスト可能
- 外部システムに依存せずテスト実行が可能

### テストファイル配置戦略

#### コンテキスト
テストファイルをどこに配置するかの方針が必要です。

#### 決定事項
ドメインおよびアプリケーションレイヤーのテストは、対象ファイルと同じディレクトリ内の__tests__ディレクトリに配置します。インフラストラクチャとインターフェースレイヤーのテストも同様の構造で実装します。

#### 影響
- ドメインとアプリケーションのテストは、実装と近い場所に配置されるため関連性が明確
- テストファイルが実装と近いため、変更時に見つけやすく維持しやすい

### ユニットテストフレームワークとしてJestを採用

#### コンテキスト
TypeScriptプロジェクトに適したテストフレームワークが必要です。

#### 決定事項
Jestとts-jestを使用してテストを実装します。すでにプロジェクトに導入されており、TypeScriptとの親和性が高いためです。

#### 影響
- TypeScriptコードをそのままテスト可能
- モック機能が充実しており、依存性の分離が容易
- スナップショットテストやカバレッジレポート機能も利用可能

## 関連ファイルとディレクトリ構造
