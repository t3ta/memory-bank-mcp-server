{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "3ab597a7-7a49-44e6-af7d-b724848e507f",
    "title": "Glossary",
    "documentType": "generic",
    "path": "glossary.md",
    "tags": [
      "glossary",
      "terminology",
      "definitions"
    ],
    "lastModified": "2025-03-17T02:13:31.719Z",
    "createdAt": "2025-03-17T02:13:31.719Z",
    "version": 1
  },
  "content": {
    "domain_terminology": "A structured collection of documentation in a Markdown format that maintains context and institutional knowledge for AI assistants. Memory banks allow for persistent storage of information across conversations.\nAn individual document within a memory bank, typically stored as a Markdown file with metadata such as tags and last modified date.\nA memory bank associated with a specific feature or fix branch. Branch memory banks contain information specific to the development work in that branch.\nA memory bank that contains project-wide information shared across all branches, such as architecture documentation, coding standards, and glossaries.\nA set of standard files that exist in every branch memory bank, providing structure and consistency:\n`branchContext.md`: Defines the purpose and goals of the branch\n`activeContext.md`: Contains current work, recent changes, and next steps\n`systemPatterns.md`: Documents technical decisions and patterns\n`progress.md`: Tracks implemented features and pending work\nA label attached to memory documents to enable categorization and searching. Tags help in organizing and finding related information across documents.A data structure that maps tags to the documents containing those tags, enabling efficient tag-based search.\n",
    "technical_terminology": "A software architecture pattern that separates concerns into concentric layers, with domain logic at the center and infrastructure details at the periphery. This separation allows for better testability, maintainability, and flexibility.\nThe innermost layer of clean architecture containing the business logic and domain models. It has no dependencies on other layers or external frameworks.\nThe layer that coordinates the domain objects to perform tasks. It contains use cases and depends only on the domain layer.\nThe layer that provides implementations for external concerns such as data storage, external APIs, and configuration. It depends on the domain and application layers.\nThe layer that handles the interaction with users or external systems. It includes controllers, presenters, and validators.\nA domain object with an identity and lifecycle. Entities encapsulate business rules and can change over time while maintaining their identity.\nAn immutable domain object without an identity, where equality is based on attribute values rather than identity.\nA component that abstracts data access logic and provides a collection-like interface for accessing domain entities.\nA specific business operation or application feature represented as a class that orchestrates domain objects to perform a task.\nAn object designed to carry data between processes or layers, typically used to transfer data between application and interface layers.\nA component that handles incoming requests, delegates work to appropriate use cases, and returns responses.\nA component that formats the output of use cases into a format suitable for the interface layer.\nA design pattern where objects receive their dependencies from an external source rather than creating them directly.\nA communication protocol used for interacting with AI models, enabling structured exchange of information and tool calls.\n",
    "acronyms_and_abbreviations": "Application Programming Interface - A set of rules and protocols that allows different software applications to communicate with each other.\nData Transfer Object - An object designed to carry data between processes or layers.\nDependency Injection - A design pattern where objects receive their dependencies rather than creating them.\nDomain-Driven Design - An approach to software development that focuses on the core domain and domain logic.\nSingle Responsibility Principle - A principle stating that a class should have only one reason to change.\nTest-Driven Development - A software development process relying on a very short development cycle where requirements are turned into specific test cases before the software is improved.\nModel Context Protocol - A protocol for structured communication with AI models.\nCommand Line Interface - A text-based interface used to interact with software by typing commands.\nFive design principles (Single responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion) intended to make object-oriented designs more understandable, flexible, and maintainable.\n",
    "projectspecific_concepts": "Branches are named with prefixes indicating their purpose:\n`feature/` - For new features\n`fix/` - For bug fixes\nThe current state of work on a branch, including current tasks, recent changes, active decisions, and next steps.A documented decision about a technical aspect of the project, including context, the decision made, and its consequences.\nA recurring solution to a common problem within the system, documented for reuse and knowledge sharing.\nThe file system path where memory bank documents are stored, with a standard structure for global and branch-specific documents.\nThe server application that provides a Model Context Protocol interface for interacting with memory banks.\nThe root directory containing the project code and documentation.\nThe root directory containing all memory banks for a workspace.\nThe relative path of a document within a memory bank.\nThe mechanism for associating documents with tags and searching for documents by tag."
  }
}