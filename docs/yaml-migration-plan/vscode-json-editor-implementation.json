{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "fca26bc8-fefe-48f9-8f83-c4f868a32312",
    "title": "VSCode JSON エディタ拡張機能の実装計画",
    "documentType": "generic",
    "path": "vscode-json-editor-implementation.md",
    "tags": [],
    "lastModified": "2025-03-21T19:30:40.798Z",
    "createdAt": "2025-03-21T19:30:40.798Z",
    "version": 1
  },
  "content": {
    "rawContent": "# VSCode JSON エディタ拡張機能の実装計画\n\n## 概要\n\nこのドキュメントでは、メモリバンクプロジェクトのJSONファイルを人間にとって見やすく表示・編集するためのVSCode拡張機能の実装計画について詳細に説明します。この拡張機能は、将来的にウェブアプリケーションとしても展開することを前提としていますが、まずはVSCode拡張機能として実装します。\n\n## 目標\n\n- メモリバンクのJSONファイルを人間にとって読みやすく表示する\n- 構造化されたエディタでJSONファイルの編集を容易にする\n- JSONスキーマに基づいた検証と自動補完を提供する\n- 将来的なウェブ展開を見据えた設計を行う\n\n## 拡張機能の基本構造\n\n```\nmemory-bank-json-editor/\n├── .vscode/                  # VSCode設定\n├── src/\n│   ├── extension.ts          # 拡張機能のエントリーポイント\n│   ├── editor/\n│   │   ├── jsonEditor.ts     # カスタムエディタの実装\n│   │   ├── editorProvider.ts # エディタプロバイダー\n│   │   └── webview.ts        # Webviewの管理\n│   ├── schema/\n│   │   ├── schemaLoader.ts   # JSONスキーマのロード\n│   │   └── validator.ts      # スキーマ検証\n│   ├── utils/\n│   │   ├── formatter.ts      # JSONフォーマッター\n│   │   └── parser.ts         # JSONパーサー\n│   └── views/\n│       ├── components/       # UIコンポーネント\n│       └── webview.html      # Webviewのテンプレート\n├── media/                    # アイコンなどの静的ファイル\n├── package.json              # 拡張機能のマニフェスト\n└── tsconfig.json             # TypeScript設定\n```\n\n## 主要機能と実装方法\n\n### 1. カスタムエディタの実装\n\nVSCodeのカスタムエディタAPIを使用して、JSONファイル用のカスタムエディタを実装します。\n\n```typescript\n// src/editor/editorProvider.ts\nimport * as vscode from 'vscode';\nimport { JsonEditorDocument } from './jsonEditor';\n\nexport class JsonEditorProvider implements vscode.CustomEditorProvider {\n  private static readonly viewType = 'memoryBank.jsonEditor';\n\n  constructor(private readonly context: vscode.ExtensionContext) {}\n\n  public static register(context: vscode.ExtensionContext): vscode.Disposable {\n    const provider = new JsonEditorProvider(context);\n    return vscode.window.registerCustomEditorProvider(\n      JsonEditorProvider.viewType,\n      provider,\n      {\n        webviewOptions: {\n          retainContextWhenHidden: true,\n        },\n        supportsMultipleEditorsPerDocument: false,\n      }\n    );\n  }\n\n  // カスタムエディタの実装\n  async resolveCustomEditor(\n    document: vscode.TextDocument,\n    webviewPanel: vscode.WebviewPanel,\n    token: vscode.CancellationToken\n  ): Promise<void> {\n    // Webviewの設定\n    webviewPanel.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [\n        vscode.Uri.joinPath(this.context.extensionUri, 'media'),\n        vscode.Uri.joinPath(this.context.extensionUri, 'dist'),\n      ],\n    };\n\n    // Webviewの内容を設定\n    webviewPanel.webview.html = this.getHtmlForWebview(webviewPanel.webview);\n\n    // JSONドキュメントの解析\n    const jsonDocument = new JsonEditorDocument(document);\n\n    // Webviewとの通信を設定\n    this.setupWebviewCommunication(webviewPanel, jsonDocument);\n  }\n\n  // その他の必要なメソッド...\n}\n```\n\n### 2. JSONスキーマの統合\n\nメモリバンクのJSONスキーマを読み込み、エディタに統合します。\n\n```typescript\n// src/schema/schemaLoader.ts\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class SchemaLoader {\n  private schemas: Map<string, any> = new Map();\n\n  constructor() {\n    this.loadSchemas();\n  }\n\n  private async loadSchemas() {\n    // メモリバンクのスキーマファイルを検索\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) return;\n\n    const schemaFiles = await vscode.workspace.findFiles('**/schemas/**/*.ts');\n\n    for (const file of schemaFiles) {\n      try {\n        // TypeScriptファイルからスキーマ定義を抽出\n        const content = await fs.promises.readFile(file.fsPath, 'utf-8');\n        const schemaName = path.basename(file.fsPath, '.ts');\n\n        // スキーマ定義を解析（実際の実装ではより複雑になる）\n        const schema = this.extractSchemaFromTypeScript(content);\n        if (schema) {\n          this.schemas.set(schemaName, schema);\n        }\n      } catch (error) {\n        console.error(`Failed to load schema from ${file.fsPath}:`, error);\n      }\n    }\n  }\n\n  // TypeScriptファイルからスキーマ定義を抽出するヘルパーメソッド\n  private extractSchemaFromTypeScript(content: string): any {\n    // 実際の実装では、TypeScriptのパーサーを使用して\n    // Zodスキーマ定義を抽出し、JSON Schemaに変換する\n    // ここでは簡略化のため、実装は省略\n    return null;\n  }\n\n  // ドキュメントタイプに基づいてスキーマを取得\n  public getSchemaForDocumentType(documentType: string): any {\n    return this.schemas.get(documentType) || null;\n  }\n}\n```\n\n### 3. 構造化エディタのUI\n\nWebviewを使用して、構造化エディタのUIを実装します。\n\n```html\n<!-- src/views/webview.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Memory Bank JSON Editor</title>\n  <style>\n    /* スタイルの定義 */\n    body {\n      padding: 0;\n      margin: 0;\n      font-family: var(--vscode-font-family);\n      background-color: var(--vscode-editor-background);\n      color: var(--vscode-editor-foreground);\n    }\n\n    .editor-container {\n      display: flex;\n      height: 100vh;\n    }\n\n    .form-view {\n      flex: 1;\n      padding: 20px;\n      overflow: auto;\n    }\n\n    .json-view {\n      flex: 1;\n      padding: 20px;\n      overflow: auto;\n      border-left: 1px solid var(--vscode-panel-border);\n    }\n\n    .form-group {\n      margin-bottom: 15px;\n    }\n\n    .form-label {\n      display: block;\n      margin-bottom: 5px;\n      font-weight: bold;\n    }\n\n    .form-input {\n      width: 100%;\n      padding: 5px;\n      background-color: var(--vscode-input-background);\n      color: var(--vscode-input-foreground);\n      border: 1px solid var(--vscode-input-border);\n    }\n\n    .form-textarea {\n      width: 100%;\n      min-height: 100px;\n      padding: 5px;\n      background-color: var(--vscode-input-background);\n      color: var(--vscode-input-foreground);\n      border: 1px solid var(--vscode-input-border);\n    }\n\n    .array-item {\n      margin-bottom: 10px;\n      padding: 10px;\n      border: 1px solid var(--vscode-panel-border);\n      background-color: var(--vscode-editor-background);\n    }\n\n    .array-controls {\n      margin-top: 10px;\n    }\n\n    button {\n      padding: 5px 10px;\n      background-color: var(--vscode-button-background);\n      color: var(--vscode-button-foreground);\n      border: none;\n      cursor: pointer;\n    }\n\n    button:hover {\n      background-color: var(--vscode-button-hoverBackground);\n    }\n  </style>\n</head>\n<body>\n  <div class=\"editor-container\">\n    <div class=\"form-view\" id=\"form-container\">\n      <!-- フォームはJavaScriptで動的に生成 -->\n    </div>\n    <div class=\"json-view\">\n      <pre id=\"json-preview\"></pre>\n    </div>\n  </div>\n\n  <script>\n    // Webviewのスクリプト\n    // 実際の実装では、webpackでバンドルされたJSファイルを読み込む\n  </script>\n</body>\n</html>\n```\n\n### 4. Webviewとの通信\n\n拡張機能とWebview間の通信を設定します。\n\n```typescript\n// src/editor/webview.ts\nimport * as vscode from 'vscode';\nimport { JsonEditorDocument } from './jsonEditor';\n\nexport function setupWebviewCommunication(\n  webviewPanel: vscode.WebviewPanel,\n  document: JsonEditorDocument\n) {\n  // 初期データをWebviewに送信\n  webviewPanel.webview.postMessage({\n    type: 'init',\n    content: document.getData(),\n    schema: document.getSchema(),\n  });\n\n  // Webviewからのメッセージを処理\n  webviewPanel.webview.onDidReceiveMessage(\n    async (message) => {\n      switch (message.type) {\n        case 'update':\n          // ドキュメントを更新\n          await document.update(message.content);\n          break;\n\n        case 'validate':\n          // スキーマ検証を実行\n          const validationResult = document.validate(message.content);\n          webviewPanel.webview.postMessage({\n            type: 'validation-result',\n            result: validationResult,\n          });\n          break;\n\n        case 'format':\n          // JSONをフォーマット\n          const formatted = document.format();\n          webviewPanel.webview.postMessage({\n            type: 'formatted',\n            content: formatted,\n          });\n          break;\n      }\n    },\n    undefined,\n    document.disposables\n  );\n\n  // ドキュメントの変更をWebviewに通知\n  document.onDidChange((data) => {\n    webviewPanel.webview.postMessage({\n      type: 'update',\n      content: data,\n    });\n  });\n}\n```\n\n### 5. JSONドキュメントの管理\n\nJSONドキュメントの読み込み、解析、更新を管理します。\n\n```typescript\n// src/editor/jsonEditor.ts\nimport * as vscode from 'vscode';\nimport { SchemaLoader } from '../schema/schemaLoader';\nimport { JsonValidator } from '../schema/validator';\nimport { formatJson } from '../utils/formatter';\n\nexport class JsonEditorDocument {\n  private readonly disposables: vscode.Disposable[] = [];\n  private content: any;\n  private readonly schemaLoader = new SchemaLoader();\n  private readonly validator = new JsonValidator();\n  private readonly onDidChangeEmitter = new vscode.EventEmitter<any>();\n\n  constructor(private readonly document: vscode.TextDocument) {\n    // ドキュメントの内容を解析\n    this.content = this.parseDocument();\n\n    // ドキュメントの変更を監視\n    this.disposables.push(\n      vscode.workspace.onDidChangeTextDocument((e) => {\n        if (e.document.uri.toString() === this.document.uri.toString()) {\n          this.content = this.parseDocument();\n          this.onDidChangeEmitter.fire(this.content);\n        }\n      })\n    );\n  }\n\n  // ドキュメントの内容を解析\n  private parseDocument(): any {\n    try {\n      return JSON.parse(this.document.getText());\n    } catch (error) {\n      vscode.window.showErrorMessage(`Failed to parse JSON: ${error}`);\n      return null;\n    }\n  }\n\n  // ドキュメントの内容を取得\n  public getData(): any {\n    return this.content;\n  }\n\n  // ドキュメントのスキーマを取得\n  public getSchema(): any {\n    if (!this.content || !this.content.metadata || !this.content.metadata.documentType) {\n      return null;\n    }\n\n    return this.schemaLoader.getSchemaForDocumentType(this.content.metadata.documentType);\n  }\n\n  // ドキュメントを更新\n  public async update(newContent: any): Promise<void> {\n    // 内容が変更されていない場合は何もしない\n    if (JSON.stringify(this.content) === JSON.stringify(newContent)) {\n      return;\n    }\n\n    // 新しい内容をフォーマット\n    const formatted = JSON.stringify(newContent, null, 2);\n\n    // ドキュメントを編集\n    const edit = new vscode.WorkspaceEdit();\n    edit.replace(\n      this.document.uri,\n      new vscode.Range(0, 0, this.document.lineCount, 0),\n      formatted\n    );\n\n    // 編集を適用\n    await vscode.workspace.applyEdit(edit);\n  }\n\n  // ドキュメントを検証\n  public validate(content: any = this.content): any {\n    const schema = this.getSchema();\n    if (!schema) {\n      return { valid: true }; // スキーマがない場合は検証をスキップ\n    }\n\n    return this.validator.validate(content, schema);\n  }\n\n  // ドキュメントをフォーマット\n  public format(): string {\n    return formatJson(this.content);\n  }\n\n  // 変更イベント\n  public get onDidChange(): vscode.Event<any> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  // リソースの解放\n  public dispose(): void {\n    this.disposables.forEach((d) => d.dispose());\n  }\n\n  // 破棄可能なリソースのリスト\n  public get disposables(): vscode.Disposable[] {\n    return this.disposables;\n  }\n}\n```\n\n## 開発環境のセットアップ\n\n### 必要な依存関係\n\n```json\n{\n  \"name\": \"memory-bank-json-editor\",\n  \"displayName\": \"Memory Bank JSON Editor\",\n  \"description\": \"A structured editor for Memory Bank JSON files\",\n  \"version\": \"0.1.0\",\n  \"engines\": {\n    \"vscode\": \"^1.60.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"activationEvents\": [\n    \"onCustomEditor:memoryBank.jsonEditor\"\n  ],\n  \"main\": \"./dist/extension.js\",\n  \"contributes\": {\n    \"customEditors\": [\n      {\n        \"viewType\": \"memoryBank.jsonEditor\",\n        \"displayName\": \"Memory Bank JSON Editor\",\n        \"selector\": [\n          {\n            \"filenamePattern\": \"*.json\"\n          }\n        ],\n        \"priority\": \"default\"\n      }\n    ],\n    \"commands\": [\n      {\n        \"command\": \"memoryBank.jsonEditor.format\",\n        \"title\": \"Format JSON\",\n        \"category\": \"Memory Bank\"\n      }\n    ]\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run package\",\n    \"compile\": \"webpack\",\n    \"watch\": \"webpack --watch\",\n    \"package\": \"webpack --mode production --devtool hidden-source-map\",\n    \"test-compile\": \"tsc -p ./\",\n    \"test-watch\": \"tsc -watch -p ./\",\n    \"pretest\": \"npm run test-compile && npm run lint\",\n    \"lint\": \"eslint src --ext ts\",\n    \"test\": \"node ./out/test/runTest.js\"\n  },\n  \"devDependencies\": {\n    \"@types/glob\": \"^7.1.3\",\n    \"@types/mocha\": \"^8.2.2\",\n    \"@types/node\": \"14.x\",\n    \"@types/vscode\": \"^1.60.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^4.26.0\",\n    \"@typescript-eslint/parser\": \"^4.26.0\",\n    \"eslint\": \"^7.27.0\",\n    \"glob\": \"^7.1.7\",\n    \"mocha\": \"^8.4.0\",\n    \"ts-loader\": \"^9.2.2\",\n    \"typescript\": \"^4.3.2\",\n    \"vscode-test\": \"^1.5.2\",\n    \"webpack\": \"^5.38.1\",\n    \"webpack-cli\": \"^4.7.0\"\n  },\n  \"dependencies\": {\n    \"ajv\": \"^8.6.0\",\n    \"jsonc-parser\": \"^3.0.0\"\n  }\n}\n```\n\n### webpack設定\n\n```javascript\n// webpack.config.js\nconst path = require('path');\n\nconst config = {\n  target: 'node',\n  entry: './src/extension.ts',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2',\n    devtoolModuleFilenameTemplate: '../[resource-path]'\n  },\n  devtool: 'source-map',\n  externals: {\n    vscode: 'commonjs vscode'\n  },\n  resolve: {\n    extensions: ['.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'ts-loader'\n          }\n        ]\n      }\n    ]\n  }\n};\n\n// Webview用の設定\nconst webviewConfig = {\n  target: 'web',\n  entry: './src/webview/index.ts',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'webview.js'\n  },\n  devtool: 'source-map',\n  resolve: {\n    extensions: ['.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'ts-loader'\n          }\n        ]\n      }\n    ]\n  }\n};\n\nmodule.exports = [config, webviewConfig];\n```\n\n## 実装ステップ\n\n### フェーズ1: 基本機能の実装（2週間）\n\n1. **プロジェクトのセットアップ**:\n   - VSCode拡張機能の基本構造を作成\n   - 必要な依存関係をインストール\n   - 開発環境の設定\n\n2. **カスタムエディタの基本実装**:\n   - カスタムエディタプロバイダーの実装\n   - JSONファイルの読み込みと表示\n   - 基本的な編集機能の実装\n\n3. **Webviewの実装**:\n   - Webviewのテンプレート作成\n   - 基本的なUIコンポーネントの実装\n   - 拡張機能とWebview間の通信設定\n\n### フェーズ2: 高度な機能の実装（2週間）\n\n1. **JSONスキーマの統合**:\n   - スキーマローダーの実装\n   - スキーマに基づいた検証機能の実装\n   - エラー表示の実装\n\n2. **構造化エディタの拡張**:\n   - フォームベースの編集インターフェースの実装\n   - ドキュメントタイプに応じたフォームの動的生成\n   - 配列やネストされたオブジェクトの編集サポート\n\n3. **フォーマットと検証**:\n   - JSONフォーマッターの実装\n   - リアルタイム検証の実装\n   - エラーと警告の表示\n\n### フェーズ3: ユーザー体験の向上（1週間）\n\n1. **UIの改善**:\n   - テーマサポートの追加\n   - アクセシビリティの向上\n   - キーボードショートカットの実装\n\n2. **パフォーマンスの最適化**:\n   - 大きなJSONファイルの処理の最適化\n   - メモリ使用量の最適化\n   - レンダリングパフォーマンスの向上\n\n3. **ドキュメントとテスト**:\n   - ユーザードキュメントの作成\n   - 単体テストの実装\n   - 統合テストの実装\n\n### フェーズ4: 展開と将来の拡張（1週間）\n\n1. **パッケージングと展開**:\n   - 拡張機能のパッケージング\n   - VSCode Marketplaceへの公開準備\n   - インストールと使用方法のドキュメント作成\n\n2. **将来のウェブ展開の準備**:\n   - コードの再利用可能な部分の特定\n   - ウェブアプリケーションへの移行計画の作成\n   - 共通コンポーネントのライブラリ化\n\n## テストと展開\n\n### テスト戦略\n\n1. **単体テスト**:\n   - JSONパーサーとフォーマッターのテスト\n   - スキーマ検証のテスト\n   - ユーティリティ関数のテスト\n\n2. **統合テスト**:\n   - カスタムエディタの機能テスト\n   - Webviewとの通信テスト\n   - ドキュメントの読み込みと保存のテスト\n\n3. **エンドツーエンドテスト**:\n   - 実際のJSONファイルを使用したテスト\n   - ユーザーワークフローのテスト\n   - エラー処理のテスト\n\n### 展開プロセス\n\n1. **VSCode Marketplaceへの公開**:\n   - 拡張機能のパッケージング\n   - Marketplaceへの公開\n   - バージョン管理とリリースノートの作成\n\n2. **ユーザーフィードバックの収集**:\n   - フィードバックチャネルの設定\n   - バグ報告と機能リクエストの追跡\n   - ユーザーテストの実施\n\n## 将来的なウェブ展開への移行計画\n\n### 共通コンポーネントの特定\n\n1. **再利用可能なコンポーネント**:\n   - JSONパーサーとフォーマッター\n   - スキーマ検証ロジック\n   - UIコンポーネント\n\n2. **プラットフォーム固有のコンポーネント**:\n   - VSCode API統合\n   - ファイルシステムアクセス\n   - Webviewの管理\n\n### ウェブアプリケーションへの移行\n\n1. **フロントエンドフレームワークの選定**:\n   - React、Vue、Angularなどの評価\n   - TypeScriptサポートの確認\n   - コンポーネントライブラリの評価\n\n2. **バックエンドの実装**:\n   - APIの設計\n   - ファイル管理システムの実装\n   - 認証と認可の実装\n\n3. **デプロイメント戦略**:\n   - コンテナ化（Docker）\n   - CI/CDパイプラインの設定\n   - クラウドプラットフォームの選定\n\n## 結論\n\nVSCode拡張機能としてのJSONエディタの実装は、メモリバンクプロジェクトのJSONファイルを人間にとって見やすく表示・編集するための重要なステップです。この計画に従って実装を進めることで、ユーザーフレンドリーなエディタを提供し、将来的なウェブ展開への道筋を立てることができます。\n\nフェーズごとの実装を進めることで、基本機能から高度な機能まで段階的に開発し、ユーザーフィードバックを取り入れながら改善を続けることができます。また、将来的なウェブ展開を見据えた設計を行うことで、コードの再利用性を高め、スムーズな移行を実現することができます。\n",
    "sections": {
      "": "VSCode拡張機能としてのJSONエディタの実装は、メモリバンクプロジェクトのJSONファイルを人間にとって見やすく表示・編集するための重要なステップです。この計画に従って実装を進めることで、ユーザーフレンドリーなエディタを提供し、将来的なウェブ展開への道筋を立てることができます。\n\nフェーズごとの実装を進めることで、基本機能から高度な機能まで段階的に開発し、ユーザーフィードバックを取り入れながら改善を続けることができます。また、将来的なウェブ展開を見据えた設計を行うことで、コードの再利用性を高め、スムーズな移行を実現することができます。"
    }
  }
}