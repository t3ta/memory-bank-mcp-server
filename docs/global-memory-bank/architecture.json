{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "8ac53b53-3a54-4f54-be92-72cacc63db6a",
    "title": "System Architecture",
    "documentType": "generic",
    "path": "architecture.md",
    "tags": [
      "architecture",
      "system-design",
      "clean-architecture",
      "onion-architecture"
    ],
    "lastModified": "2025-03-17T02:13:31.716Z",
    "createdAt": "2025-03-17T02:13:31.716Z",
    "version": 1
  },
  "content": {
    "overview": "Memory Bank MCP Server implements a clean architecture (also known as onion architecture) design pattern. This architecture separates the application into concentric layers, with domain logic at the center and infrastructure details at the periphery. This separation allows for better testability, maintainability, and flexibility.",
    "core_principles": [
      "Dependency Rule: Dependencies always point inward. Inner layers don't know about outer layers.",
      "Domain-Centric: The domain (business logic) is at the center of the architecture.",
      "Separation of Concerns: Each layer has a specific responsibility.",
      "Framework Independence: The core business logic doesn't depend on frameworks.",
      "Testability: The architecture makes the system easy to test."
    ],
    "architectural_layers": [
      {
        "layer": "Domain Layer",
        "description": "The domain layer is the core of the application, containing entities, value objects, repository interfaces, and domain services. This layer has no dependencies on other layers or external frameworks."
      },
      {
        "layer": "Application Layer",
        "description": "The application layer coordinates the domain objects to perform tasks, including use cases, DTOs, and interfaces. This layer depends only on the domain layer."
      },
      {
        "layer": "Infrastructure Layer",
        "description": "The infrastructure layer provides implementations for external concerns, including repositories, storage services, configuration, and external integrations. This layer depends on the domain and application layers."
      },
      {
        "layer": "Interface Layer",
        "description": "The interface layer handles the interaction with users or external systems, including controllers, presenters, and validators. This layer depends on the application layer."
      },
      {
        "layer": "Main Layer",
        "description": "The main layer is the composition root and entry point of the application, including dependency injection, configuration, and bootstrapping. This layer depends on all other layers."
      }
    ],
    "components": {
      "primary": [
        "Dependency Injection Container: Manages dependencies across the application",
        "Controllers: BranchController, GlobalController",
        "Use Cases: ReadBranchDocumentUseCase, WriteGlobalDocumentUseCase, etc.",
        "Repositories: FileSystemBranchMemoryBankRepository, FileSystemGlobalMemoryBankRepository",
        "Entities: MemoryDocument, BranchInfo, Tag",
        "Value Objects: DocumentPath",
        "Services: FileSystemService, ConfigProvider"
      ],
      "diagram": "┌────────────────────────────────────────────────────────────────┐\n│                          Main Layer                            │\n│                                                                │\n│    ┌────────────────────────────────────────────────────┐     │\n│    │                   Interface Layer                   │     │\n│    │                                                     │     │\n│    │    ┌────────────────────────────────────────┐      │     │\n│    │    │            Application Layer            │      │     │\n│    │    │                                         │      │     │\n│    │    │    ┌────────────────────────────┐      │      │     │\n│    │    │    │        Domain Layer         │      │      │     │\n│    │    │    │                             │      │      │     │\n│    │    │    │  - Entities                 │      │      │     │\n│    │    │    │  - Value Objects            │      │      │     │\n│    │    │    │  - Repository Interfaces    │      │      │     │\n│    │    │    │  - Domain Services          │      │      │     │\n│    │    │    └────────────────────────────┘      │      │     │\n│    │    │                                         │      │     │\n│    │    │  - Use Cases                            │      │     │\n│    │    │  - DTOs                                 │      │     │\n│    │    │  - Application Services                 │      │     │\n│    │    └────────────────────────────────────────┘      │     │\n│    │                                                     │     │\n│    │  - Controllers                                      │     │\n│    │  - Presenters                                       │     │\n│    │  - Validators                                       │     │\n│    └────────────────────────────────────────────────────┘     │\n│                                                                │\n│  ┌──────────────────────────────────────────────────────────┐ │\n│  │                   Infrastructure Layer                    │ │\n│  │                                                           │ │\n│  │  - Repository Implementations                             │ │\n│  │  - Storage Services                                       │ │\n│  │  - External Integrations                                  │ │\n│  └──────────────────────────────────────────────────────────┘ │\n│                                                                │\n│  - Dependency Injection                                        │\n│  - Bootstrapping                                               │\n└────────────────────────────────────────────────────────────────┘"
    },
    "design_decisions": [
      {
        "context": "The original codebase was difficult to maintain and extend, with tightly coupled components and unclear separation of concerns.",
        "decision": "We adopted clean architecture to create a more maintainable and testable codebase.",
        "consequences": [
          "Improved separation of concerns",
          "Enhanced testability",
          "Better maintainability",
          "More explicit dependencies",
          "Initial development overhead for setting up architectural boundaries"
        ]
      },
      {
        "context": "The original code had data access logic scattered throughout manager classes.",
        "decision": "We implemented the repository pattern to abstract data access.",
        "consequences": [
          "Centralized data access logic",
          "Ability to swap storage mechanisms",
          "Easier mocking for tests",
          "Clear separation of data access from business logic"
        ]
      },
      {
        "context": "The domain concepts were not clearly modeled in the original code.",
        "decision": "We applied DDD principles to model core domain concepts as entities and value objects.",
        "consequences": [
          "Richer domain model",
          "Encapsulation of business rules in the domain",
          "More intuitive code organization",
          "Better alignment with business requirements"
        ]
      },
      {
        "context": "Original code had direct dependencies between components, making testing difficult.",
        "decision": "Implemented a dependency injection container to manage dependencies.",
        "consequences": [
          "Reduced coupling between components",
          "Improved testability",
          "More explicit dependencies",
          "Enhanced configurability"
        ]
      }
    ],
    "migration_strategy": [
      "Define domain layer (entities, value objects, repository interfaces)",
      "Implement application layer (use cases, DTOs)",
      "Implement infrastructure layer (repository implementations, services)",
      "Implement interface layer (controllers, presenters)",
      "Update entry point to use the new architecture",
      "Phase out old code gradually",
      "Add comprehensive tests",
      "Update documentation"
    ],
    "further_reading": [
      "[Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)",
      "[Domain-Driven Design by Eric Evans](https://domainlanguage.com/ddd/)",
      "[Onion Architecture by Jeffrey Palermo](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/)"
    ]
  }
}
