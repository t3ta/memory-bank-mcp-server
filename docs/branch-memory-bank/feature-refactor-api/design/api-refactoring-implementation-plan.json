{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "api-refactoring-implementation-plan",
    "title": "API リファクタリング 実装計画",
    "documentType": "design",
    "path": "design/api-refactoring-implementation-plan.json",
    "tags": [],
    "createdAt": "2025-04-10T13:20:00Z",
    "lastModified": "2025-04-10T12:48:38.701Z"
  },
  "content": {
    "sections": [
      {
        "title": "概要",
        "content": "read_branch_memory_bank/read_global_memory_bankをread_documentに、write_branch_memory_bank/write_global_memory_bankをwrite_documentにリファクタリングするための実装計画を詳細に定義します。"
      },
      {
        "title": "実装計画の全体像",
        "content": "1. ヘルパークラスの実装\n2. テストの作成\n3. 新しいユースケースの実装\n4. 既存APIの修正（新APIへの委譲）\n5. コントローラーの更新\n6. ドキュメントとサンプルの更新"
      },
      {
        "title": "1. ヘルパークラスの実装",
        "content": "### 1.1 BranchResolverService\n\n```typescript\nexport class BranchResolverService {\n  constructor(\n    private readonly gitService: IGitService,\n    private readonly configProvider: IConfigProvider\n  ) {}\n\n  /**\n   * 与えられたブランチ名を検証し、必要に応じて現在のブランチを自動検出します\n   * @param providedBranchName オプショナルなブランチ名\n   * @returns 検証済みのブランチ名\n   * @throws ApplicationError ブランチ名が無効または検出できない場合\n   */\n  async resolveBranchName(providedBranchName?: string): Promise<string> {\n    // プロジェクトモードでブランチ名が提供されていない場合は自動検出\n    if (!providedBranchName) {\n      const config = this.configProvider.getConfig();\n      if (config.isProjectMode) {\n        try {\n          const currentBranch = await this.gitService.getCurrentBranchName();\n          return currentBranch;\n        } catch (error) {\n          throw ApplicationErrors.executionFailed(\n            'Branch name is required but could not be automatically determined. Please provide it explicitly or ensure you are in a Git repository.',\n            error instanceof Error ? error : undefined\n          );\n        }\n      } else {\n        throw ApplicationErrors.invalidInput('Branch name is required when not running in project mode.');\n      }\n    }\n\n    // ブランチ名のバリデーション\n    try {\n      const branchInfo = BranchInfo.create(providedBranchName);\n      return branchInfo.name;\n    } catch (error) {\n      throw ApplicationErrors.invalidInput(`Invalid branch name: ${providedBranchName}. ${error instanceof Error ? error.message : ''}`);\n    }\n  }\n}\n```\n\n### 1.2 DocumentRepositorySelector\n\n```typescript\nexport class DocumentRepositorySelector {\n  constructor(\n    private readonly branchRepository: IBranchMemoryBankRepository,\n    private readonly globalRepository: IGlobalMemoryBankRepository,\n    private readonly branchResolver: BranchResolverService\n  ) {}\n\n  /**\n   * スコープとブランチ名に基づいて適切なリポジトリを返します\n   * @param scope 'branch' または 'global'\n   * @param branchName ブランチスコープの場合に使用されるブランチ名（オプション）\n   * @returns リポジトリアダプタとブランチ情報（該当する場合）\n   * @throws ApplicationError スコープが無効な場合\n   */\n  async getRepository(scope: 'branch' | 'global', branchName?: string): Promise<{\n    repository: IDocumentRepository;\n    branchInfo?: BranchInfo;\n  }> {\n    if (scope === 'branch') {\n      // ブランチ名を解決・検証\n      const resolvedBranchName = await this.branchResolver.resolveBranchName(branchName);\n      const branchInfo = BranchInfo.create(resolvedBranchName);\n\n      // ブランチリポジトリ用のアダプタを作成\n      const repository: IDocumentRepository = {\n        getDocument: async (path: DocumentPath) => {\n          return this.branchRepository.getDocument(branchInfo, path);\n        },\n        saveDocument: async (doc: MemoryDocument) => {\n          await this.branchRepository.saveDocument(branchInfo, doc);\n        }\n      };\n\n      return { repository, branchInfo };\n    } else if (scope === 'global') {\n      // グローバルリポジトリ用のアダプタを作成\n      const repository: IDocumentRepository = {\n        getDocument: async (path: DocumentPath) => {\n          return this.globalRepository.getDocument(path);\n        },\n        saveDocument: async (doc: MemoryDocument) => {\n          await this.globalRepository.saveDocument(doc);\n          await this.globalRepository.updateTagsIndex(); // グローバル特有のタグインデックス更新\n        }\n      };\n\n      return { repository };\n    } else {\n      throw ApplicationErrors.invalidInput(`Invalid scope: ${scope}. Must be 'branch' or 'global'.`);\n    }\n  }\n}\n```"
      },
      {
        "title": "2. テストの作成",
        "content": "### 2.1 ヘルパークラスのユニットテスト\n- `BranchResolverService.test.ts`\n- `DocumentRepositorySelector.test.ts`\n\n### 2.2 新APIの統合テスト\n- `ReadDocumentUseCase.integration.test.ts`\n- `WriteDocumentUseCase.integration.test.ts`\n\nテストの詳細は `api-refactoring-test-strategy.json` を参照してください。"
      },
      {
        "title": "3. 新しいユースケースの実装",
        "content": "### 3.1 WriteDocumentUseCase.ts\n\n```typescript\nexport interface WriteDocumentInput {\n  scope: 'branch' | 'global';\n  branch?: string;\n  path: string;\n  docs?: string;\n  content?: string | object;\n  patches?: JsonPatchOp[];\n  tags?: string[];\n  returnContent?: boolean;\n}\n\nexport interface WriteDocumentOutput {\n  document: Omit<DocumentDTO, 'content' | 'tags'> & {\n    content?: string;\n    tags?: string[];\n  };\n}\n\nexport class WriteDocumentUseCase implements IUseCase<WriteDocumentInput, WriteDocumentOutput> {\n  constructor(\n    private readonly repositorySelector: DocumentRepositorySelector,\n    private readonly documentWriterService: DocumentWriterService\n  ) {}\n\n  async execute(input: WriteDocumentInput): Promise<WriteDocumentOutput> {\n    // 入力検証\n    this.validateInput(input);\n\n    // リポジトリの取得\n    const { repository, branchInfo } = await this.repositorySelector.getRepository(\n      input.scope, \n      input.branch\n    );\n\n    // ドキュメントパスの作成\n    const documentPath = DocumentPath.create(input.path);\n\n    // タグの準備\n    const tags = (input.tags ?? []).map(tag => Tag.create(tag));\n\n    // DocumentWriterServiceの入力準備\n    const writerInput: DocumentWriterInput = {\n      path: documentPath,\n      content: input.content,\n      patches: input.patches,\n      tags\n    };\n\n    // ドキュメントの書き込み\n    const savedDocument = await this.documentWriterService.write(repository, writerInput);\n\n    // 結果の整形\n    const shouldReturnContent = input.returnContent === true;\n    const outputDocument: WriteDocumentOutput['document'] = {\n      path: savedDocument.path.value,\n      lastModified: savedDocument.lastModified.toISOString(),\n      ...(shouldReturnContent && {\n        content: savedDocument.content,\n        tags: savedDocument.tags.map(tag => tag.value)\n      })\n    };\n\n    return { document: outputDocument };\n  }\n\n  private validateInput(input: WriteDocumentInput): void {\n    // スコープのバリデーション\n    if (input.scope !== 'branch' && input.scope !== 'global') {\n      throw ApplicationErrors.invalidInput(`Invalid scope: ${input.scope}. Must be 'branch' or 'global'.`);\n    }\n\n    // パスのバリデーション\n    if (!input.path) {\n      throw ApplicationErrors.invalidInput('Document path is required');\n    }\n\n    // contentとpatchesの排他的バリデーション\n    const hasContent = input.content !== undefined && input.content !== null;\n    const hasPatches = input.patches && Array.isArray(input.patches) && input.patches.length > 0;\n\n    if (!hasContent && !hasPatches) {\n      throw ApplicationErrors.invalidInput('Either document content or patches must be provided');\n    }\n\n    if (hasContent && hasPatches) {\n      throw ApplicationErrors.invalidInput('Cannot provide both document content and patches simultaneously');\n    }\n  }\n}\n```\n\n### 3.2 ReadDocumentUseCase.ts\n\n```typescript\nexport interface ReadDocumentInput {\n  scope: 'branch' | 'global';\n  branch?: string;\n  path: string;\n  docs?: string;\n}\n\nexport interface ReadDocumentOutput {\n  document: DocumentDTO;\n}\n\nexport class ReadDocumentUseCase implements IUseCase<ReadDocumentInput, ReadDocumentOutput> {\n  constructor(\n    private readonly repositorySelector: DocumentRepositorySelector\n  ) {}\n\n  async execute(input: ReadDocumentInput): Promise<ReadDocumentOutput> {\n    // 入力検証\n    this.validateInput(input);\n\n    // リポジトリの取得\n    const { repository } = await this.repositorySelector.getRepository(\n      input.scope, \n      input.branch\n    );\n\n    // ドキュメントパスの作成\n    const documentPath = DocumentPath.create(input.path);\n\n    // ドキュメントの取得\n    const document = await repository.getDocument(documentPath);\n\n    if (!document) {\n      throw DomainErrors.documentNotFound(input.path, \n        input.scope === 'branch' && input.branch ? { branchName: input.branch } : undefined\n      );\n    }\n\n    // コンテンツのパース（必要に応じて）\n    let parsedContent: string | object;\n    try {\n      parsedContent = JSON.parse(document.content);\n    } catch (parseError) {\n      parsedContent = document.content;\n    }\n\n    return {\n      document: {\n        path: document.path.value,\n        content: parsedContent,\n        tags: document.tags.map(tag => tag.value),\n        lastModified: document.lastModified.toISOString(),\n      },\n    };\n  }\n\n  private validateInput(input: ReadDocumentInput): void {\n    // スコープのバリデーション\n    if (input.scope !== 'branch' && input.scope !== 'global') {\n      throw ApplicationErrors.invalidInput(`Invalid scope: ${input.scope}. Must be 'branch' or 'global'.`);\n    }\n\n    // パスのバリデーション\n    if (!input.path) {\n      throw ApplicationErrors.invalidInput('Document path is required');\n    }\n  }\n}\n```"
      },
      {
        "title": "4. 既存APIの修正（新APIへの委譲）",
        "content": "### 4.1 WriteBranchDocumentUseCase.ts（修正版）\n\n```typescript\nexport class WriteBranchDocumentUseCase\n  implements IUseCase<WriteBranchDocumentInput, WriteBranchDocumentOutput> {\n\n  constructor(\n    private readonly writeDocumentUseCase: WriteDocumentUseCase\n  ) {}\n\n  async execute(input: WriteBranchDocumentInput): Promise<WriteBranchDocumentOutput> {\n    // 新しいAPIへ委譲\n    const result = await this.writeDocumentUseCase.execute({\n      scope: 'branch',\n      branch: input.branchName,\n      path: input.document.path,\n      content: input.document.content,\n      patches: input.patches,\n      tags: input.document.tags,\n      returnContent: input.returnContent\n    });\n\n    return result;\n  }\n}\n```\n\n### 4.2 ReadBranchDocumentUseCase.ts（修正版）\n\n```typescript\nexport class ReadBranchDocumentUseCase\n  implements IUseCase<ReadBranchDocumentInput, ReadBranchDocumentOutput> {\n\n  constructor(\n    private readonly readDocumentUseCase: ReadDocumentUseCase\n  ) {}\n\n  async execute(input: ReadBranchDocumentInput): Promise<ReadBranchDocumentOutput> {\n    // 新しいAPIへ委譲\n    return await this.readDocumentUseCase.execute({\n      scope: 'branch',\n      branch: input.branchName,\n      path: input.path\n    });\n  }\n}\n```\n\n### 4.3 WriteGlobalDocumentUseCase.ts（修正版）\n\n```typescript\nexport class WriteGlobalDocumentUseCase\n  implements IUseCase<WriteGlobalDocumentInput, WriteGlobalDocumentOutput> {\n\n  constructor(\n    private readonly writeDocumentUseCase: WriteDocumentUseCase\n  ) {}\n\n  async execute(input: WriteGlobalDocumentInput): Promise<WriteGlobalDocumentOutput> {\n    // 新しいAPIへ委譲\n    const result = await this.writeDocumentUseCase.execute({\n      scope: 'global',\n      path: input.document.path,\n      content: input.document.content,\n      patches: input.patches,\n      tags: input.document.tags,\n      returnContent: input.returnContent\n    });\n\n    return result;\n  }\n}\n```\n\n### 4.4 ReadGlobalDocumentUseCase.ts（修正版）\n\n```typescript\nexport class ReadGlobalDocumentUseCase\n  implements IUseCase<ReadGlobalDocumentInput, ReadGlobalDocumentOutput> {\n\n  constructor(\n    private readonly readDocumentUseCase: ReadDocumentUseCase\n  ) {}\n\n  async execute(input: ReadGlobalDocumentInput): Promise<ReadGlobalDocumentOutput> {\n    // 新しいAPIへ委譲\n    return await this.readDocumentUseCase.execute({\n      scope: 'global',\n      path: input.path\n    });\n  }\n}\n```"
      },
      {
        "title": "5. コントローラーの更新",
        "content": "### 5.1 新しいコントローラーの作成\n\n```typescript\nexport class DocumentController {\n  constructor(\n    private readonly writeDocumentUseCase: WriteDocumentUseCase,\n    private readonly readDocumentUseCase: ReadDocumentUseCase\n  ) {}\n\n  async writeDocument(input: WriteDocumentInput): Promise<WriteDocumentOutput> {\n    return await this.writeDocumentUseCase.execute(input);\n  }\n\n  async readDocument(input: ReadDocumentInput): Promise<ReadDocumentOutput> {\n    return await this.readDocumentUseCase.execute(input);\n  }\n}\n```\n\n### 5.2 既存コントローラーの修正\nBranchControllerとGlobalControllerは、新しいDocumentControllerを利用するように修正します。"
      },
      {
        "title": "6. 依存性注入の設定",
        "content": "DIContainerの設定を更新し、新しいクラスをコンテナに登録します。\n\n```typescript\n// providers.ts or DIContainer.ts の一部\n\n// ヘルパークラスの登録\nconst branchResolver = new BranchResolverService(gitService, configProvider);\ncontainer.register<BranchResolverService>('branchResolverService', branchResolver);\n\nconst repositorySelector = new DocumentRepositorySelector(\n  branchMemoryBankRepository,\n  globalMemoryBankRepository,\n  branchResolver\n);\ncontainer.register<DocumentRepositorySelector>('documentRepositorySelector', repositorySelector);\n\n// 新しいユースケースの登録\nconst writeDocumentUseCase = new WriteDocumentUseCase(\n  repositorySelector,\n  documentWriterService\n);\ncontainer.register<WriteDocumentUseCase>('writeDocumentUseCase', writeDocumentUseCase);\n\nconst readDocumentUseCase = new ReadDocumentUseCase(repositorySelector);\ncontainer.register<ReadDocumentUseCase>('readDocumentUseCase', readDocumentUseCase);\n\n// 既存ユースケースの再登録（新しいユースケースに依存するようになった）\nconst writeBranchDocumentUseCase = new WriteBranchDocumentUseCase(writeDocumentUseCase);\ncontainer.register<WriteBranchDocumentUseCase>('writeBranchDocumentUseCase', writeBranchDocumentUseCase);\n\nconst readBranchDocumentUseCase = new ReadBranchDocumentUseCase(readDocumentUseCase);\ncontainer.register<ReadBranchDocumentUseCase>('readBranchDocumentUseCase', readBranchDocumentUseCase);\n\nconst writeGlobalDocumentUseCase = new WriteGlobalDocumentUseCase(writeDocumentUseCase);\ncontainer.register<WriteGlobalDocumentUseCase>('writeGlobalDocumentUseCase', writeGlobalDocumentUseCase);\n\nconst readGlobalDocumentUseCase = new ReadGlobalDocumentUseCase(readDocumentUseCase);\ncontainer.register<ReadGlobalDocumentUseCase>('readGlobalDocumentUseCase', readGlobalDocumentUseCase);\n```"
      },
      {
        "title": "7. ツール定義の更新",
        "content": "tools/definitions.ts を更新して、新しいAPIを定義します。\n\n```typescript\n// write_document ツール定義\n{\n  name: 'write_document',\n  description: 'Write a document to branch or global memory bank.',\n  parameters: {\n    type: 'object',\n    properties: {\n      scope: {\n        type: 'string',\n        enum: ['branch', 'global'],\n        description: 'Scope of the document (branch or global)'\n      },\n      branch: {\n        type: 'string',\n        description: 'Branch name (required for branch scope when not in project mode)'\n      },\n      path: {\n        type: 'string',\n        description: 'Document path'\n      },\n      docs: {\n        type: 'string',\n        description: 'Path to docs directory (optional in project mode)'\n      },\n      content: {\n        description: 'Document content (cannot be used with patches)'\n      },\n      patches: {\n        type: 'array',\n        items: {\n          type: 'object'\n        },\n        description: 'JSON Patch operations (cannot be used with content)'\n      },\n      tags: {\n        type: 'array',\n        items: {\n          type: 'string'\n        },\n        description: 'Document tags'\n      },\n      returnContent: {\n        type: 'boolean',\n        description: 'If true, return the document content in the response'\n      }\n    },\n    required: ['scope', 'path']\n  }\n}\n\n// read_document ツール定義\n{\n  name: 'read_document',\n  description: 'Read a document from branch or global memory bank.',\n  parameters: {\n    type: 'object',\n    properties: {\n      scope: {\n        type: 'string',\n        enum: ['branch', 'global'],\n        description: 'Scope of the document (branch or global)'\n      },\n      branch: {\n        type: 'string',\n        description: 'Branch name (required for branch scope when not in project mode)'\n      },\n      path: {\n        type: 'string',\n        description: 'Document path'\n      },\n      docs: {\n        type: 'string',\n        description: 'Path to docs directory (optional in project mode)'\n      }\n    },\n    required: ['scope', 'path']\n  }\n}\n```"
      },
      {
        "title": "マイルストーン",
        "content": "1. **M1: ヘルパークラス実装完了**\n   - BranchResolverServiceの実装とテスト\n   - DocumentRepositorySelectorの実装とテスト\n\n2. **M2: 新しいユースケース実装完了**\n   - WriteDocumentUseCaseの実装とテスト\n   - ReadDocumentUseCaseの実装とテスト\n\n3. **M3: 既存APIの修正完了**\n   - 既存UseCaseが新UseCaseに委譲するよう修正\n   - 既存テストの確認と修正\n\n4. **M4: コントローラーと依存性注入の更新完了**\n   - 新しいコントローラーの作成\n   - 依存性注入の設定更新\n\n5. **M5: ツールとドキュメントの更新完了**\n   - 新しいAPIのツール定義\n   - ドキュメントの更新"
      },
      {
        "title": "課題と対策",
        "content": "1. **後方互換性の維持**\n   - 既存APIは内部的に新APIに委譲するように実装し、外部インターフェースは変更しない\n   - 既存のテストケースがすべて合格することを確認する\n\n2. **依存性の管理**\n   - DIコンテナを適切に更新し、依存関係を管理する\n   - 循環依存を避けるための設計を心がける\n\n3. **エラーメッセージの一貫性**\n   - 統一されたエラーメッセージと形式を使用する\n   - エラーチェーンを活用して、元のエラー情報を保持する\n\n4. **テストカバレッジの確保**\n   - 重複のないテストセットを作成する\n   - エッジケースを含むテストケースを設計する"
      }
    ]
  }
}