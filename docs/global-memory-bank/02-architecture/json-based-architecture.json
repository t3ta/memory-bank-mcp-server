{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "79273e47-fb6c-4795-9588-413acba271e7",
    "title": "Memory Bank 2.0: JSON ベースアーキテクチャ詳細設計",
    "documentType": "generic",
    "path": "json-based-architecture.md",
    "tags": [
      "architecture",
      "json",
      "design",
      "v2"
    ],
    "lastModified": "2025-03-21T07:21:59.901Z",
    "createdAt": "2025-03-17T02:13:31.720Z",
    "version": 1
  },
  "content": {
    "rawContent": "# Memory Bank 2.0: JSON ベースアーキテクチャ詳細設計\n\ntags: #architecture #json #design #version-2\n\n## 概要\n\nこのドキュメントは Memory Bank 2.0 のJSON専用アーキテクチャの詳細設計を記述します。バージョン2.0では、Markdownサポートを完全に廃止し、JSONをデータ保存形式として一本化します。\n\n## データモデル\n\n### 基本スキーマ構造\n\nMemory Bank 2.0のすべてのドキュメントは、以下の基本構造に従います：\n\n```typescript\ninterface BaseJsonDocument {\n  schema: string;         // 例: \"memory_document_v2\"\n  metadata: {\n    id: string;           // ドキュメント一意識別子 (UUID v4)\n    title: string;        // ドキュメントタイトル\n    documentType: string; // ドキュメントタイプ識別子\n    path: string;         // 相対パス\n    tags: string[];       // タグ配列\n    created: string;      // 作成日時 (ISO 8601)\n    lastModified: string; // 最終更新日時 (ISO 8601)\n    version: number;      // ドキュメントバージョン (1から開始)\n  };\n  content: Record<string, unknown>; // ドキュメントタイプ固有のコンテンツ\n}\n```\n\n### ドキュメント ID\n\n各ドキュメントは一意のIDを持ち、ファイル名や相対パスが変更されても追跡可能にします。\nこれにより将来的なデータベース移行も容易になります。\n\n### コアドキュメントタイプ\n\n#### ブランチコンテキスト\n\n```typescript\ninterface BranchContextContent {\n  branchName: string;     // ブランチ名\n  purpose: string;        // 目的説明\n  createdAt: string;      // ブランチ作成日時 (ISO 8601)\n  userStories: {\n    id: string;           // ストーリーID (UUID v4)\n    description: string;  // ストーリー説明\n    completed: boolean;   // 完了フラグ\n    priority: number;     // 優先度 (1-5)\n  }[];\n  additionalNotes?: string; // 追加メモ (オプション)\n}\n```\n\n#### アクティブコンテキスト\n\n```typescript\ninterface ActiveContextContent {\n  currentWork: string;    // 現在の作業内容\n  recentChanges: {\n    date: string;         // 変更日時 (ISO 8601)\n    description: string;  // 変更内容\n  }[];\n  activeDecisions: {\n    id: string;           // 決定ID (UUID v4)\n    description: string;  // 決定内容\n    reason?: string;      // 決定理由 (オプション)\n  }[];\n  considerations: {\n    id: string;           // 検討項目ID (UUID v4)\n    description: string;  // 検討内容\n    status: 'open' | 'resolved' | 'deferred'; // 状態\n  }[];\n  nextSteps: {\n    id: string;           // ステップID (UUID v4)\n    description: string;  // 次のステップ\n    priority: 'low' | 'medium' | 'high'; // 優先度\n  }[];\n}\n```\n\n#### 進捗状況\n\n```typescript\ninterface ProgressContent {\n  workingFeatures: {\n    id: string;           // 機能ID (UUID v4)\n    description: string;  // 機能説明\n    implementedAt: string; // 実装日時 (ISO 8601)\n  }[];\n  pendingImplementation: {\n    id: string;           // 実装予定ID (UUID v4)\n    description: string;  // 実装予定内容\n    priority: 'low' | 'medium' | 'high'; // 優先度\n    estimatedCompletion?: string; // 完了予定日 (オプション)\n  }[];\n  status: 'planning' | 'in-development' | 'testing' | 'completed'; // 全体状態\n  completionPercentage: number; // 完了率 (0-100)\n  knownIssues: {\n    id: string;           // 問題ID (UUID v4)\n    description: string;  // 問題説明\n    severity: 'low' | 'medium' | 'high' | 'critical'; // 重要度\n    workaround?: string;  // 回避策 (オプション)\n  }[];\n}\n```\n\n#### システムパターン\n\n```typescript\ninterface SystemPatternsContent {\n  technicalDecisions: {\n    id: string;           // 決定ID (UUID v4)\n    title: string;        // タイトル\n    context: string;      // コンテキスト\n    decision: string;     // 決定内容\n    consequences: {\n      positive: string[]; // ポジティブな影響\n      negative: string[]; // ネガティブな影響\n    };\n    status: 'proposed' | 'accepted' | 'deprecated'; // 状態\n    date: string;         // 決定日時 (ISO 8601)\n    alternatives?: {      // 検討した代替案 (オプション)\n      description: string;\n      reason: string;     // 採用しなかった理由\n    }[];\n  }[];\n  implementationPatterns?: { // 実装パターン (オプション)\n    id: string;           // パターンID (UUID v4)\n    name: string;         // パターン名\n    description: string;  // 説明\n    useCases: string[];   // ユースケース\n    codeExample?: string; // コード例 (オプション)\n  }[];\n}\n```\n\n### タグシステム\n\nタグは単純な文字列配列としてメタデータに格納されます。タグ検索を効率化するために、以下の拡張機能を導入します：\n\n1. インデックス生成 - すべてのタグとドキュメントIDのマッピングを持つインデックスファイル\n2. 階層タグ - ドット表記による階層構造（例: `feature.ui`, `feature.api`）\n3. タググループ - 関連タグのグループ化とエイリアス\n\n## ファイルシステム構造\n\n### 基本ディレクトリ構造\n\n```\ndocs/\n  ├── branch-memory-bank/\n  │   ├── feature-xxx/\n  │   │   ├── index.json           # ブランチインデックス\n  │   │   ├── branchContext.json   # ブランチコンテキスト\n  │   │   ├── activeContext.json   # アクティブコンテキスト\n  │   │   ├── progress.json        # 進捗状況\n  │   │   ├── systemPatterns.json  # システムパターン\n  │   │   └── ..                  # その他ドキュメント\n  │   └── ..\n  ├── global-memory-bank/\n  │   ├── index.json               # グローバルインデックス\n  │   ├── architecture.json        # アーキテクチャ\n  │   ├── coding-standards.json    # コーディング規約\n  │   └── ..                      # その他ドキュメント\n  └── .index/                      # インデックスディレクトリ\n      ├── tags.json                # タグインデックス\n      ├── documents.json           # ドキュメントメタデータ\n      └── relations.json           # ドキュメント関係\n```\n\n### インデックスファイル\n\n各メモリバンクはインデックスファイルを持ち、含まれるすべてのドキュメントのメタデータの概要を提供します：\n\n```typescript\ninterface MemoryBankIndex {\n  name: string;           // メモリバンク名\n  path: string;           // 相対パス\n  lastUpdated: string;    // 最終更新日時 (ISO 8601)\n  documents: {\n    id: string;           // ドキュメントID\n    title: string;        // タイトル\n    path: string;         // 相対パス\n    documentType: string; // ドキュメントタイプ\n    tags: string[];       // タグ配列\n    lastModified: string; // 最終更新日時\n  }[];\n}\n```\n\n## データアクセスレイヤー\n\n### リポジトリインターフェイス\n\n```typescript\ninterface IMemoryDocumentRepository {\n  // 基本CRUD操作\n  findById(id: string): Promise<JsonDocument | null>;\n  findByPath(path: DocumentPath): Promise<JsonDocument | null>;\n  save(document: JsonDocument): Promise<void>;\n  delete(id: string): Promise<boolean>;\n  \n  // 検索・クエリ操作\n  list(): Promise<DocumentMetadata[]>;\n  findByTags(tags: string[], matchAll?: boolean): Promise<JsonDocument[]>;\n  search(query: string): Promise<DocumentMetadata[]>;\n  \n  // インデックス操作\n  updateIndex(): Promise<void>;\n  getIndex(): Promise<MemoryBankIndex>;\n}\n```\n\n### ファイルシステム実装\n\n```typescript\nclass FileSystemJsonDocumentRepository implements IMemoryDocumentRepository {\n  constructor(\n    private readonly basePath: string,\n    private readonly fileSystemService: IFileSystemService,\n    private readonly indexService: IIndexService\n  ) {}\n  \n  // 実装詳細\n  // ..\n}\n```\n\n### インデックスサービス\n\n```typescript\ninterface IIndexService {\n  buildDocumentIndex(basePath: string): Promise<void>;\n  buildTagIndex(basePath: string): Promise<void>;\n  findDocumentsByTag(tag: string): Promise<string[]>; // ドキュメントID配列を返す\n  findRelatedDocuments(documentId: string): Promise<string[]>;\n  addDocument(document: JsonDocument): Promise<void>;\n  removeDocument(documentId: string): Promise<void>;\n  updateDocument(document: JsonDocument): Promise<void>;\n}\n```\n\n## ドメインロジック\n\n### エンティティ\n\n```typescript\nclass JsonDocument {\n  private readonly props: JsonDocumentProps;\n\n  constructor(props: JsonDocumentProps) {\n    this.props = {\n      ..props,\n      metadata: {\n        ..props.metadata,\n        lastModified: new Date().toISOString()\n      }\n    };\n  }\n\n  static create(props: JsonDocumentProps): JsonDocument {\n    // バリデーションロジック\n    return new JsonDocument(props);\n  }\n\n  static createFromRaw(raw: unknown): JsonDocument {\n    // JSONの検証とパース\n    // ZodまたはAjvでのスキーマ検証\n    return new JsonDocument(validatedData);\n  }\n\n  // ゲッター、メソッド等\n  get id(): string { /* .. */ }\n  get type(): string { /* .. */ }\n  get content(): Record<string, unknown> { /* .. */ }\n  \n  hasTag(tag: string): boolean { /* .. */ }\n  addTag(tag: string): JsonDocument { /* .. */ }\n  removeTag(tag: string): JsonDocument { /* .. */ }\n  \n  updateContent(content: Record<string, unknown>): JsonDocument { /* .. */ }\n  \n  // シリアライズ\n  toJSON(): Record<string, unknown> { /* .. */ }\n  \n  // プレゼンテーション用にMarkdown形式に変換（オプション）\n  toMarkdown(): string { /* .. */ }\n}\n```\n\n### 値オブジェクト\n\n```typescript\nclass DocumentId {\n  private readonly value: string;\n  \n  private constructor(value: string) {\n    this.value = value;\n  }\n  \n  static create(): DocumentId {\n    return new DocumentId(uuid.v4());\n  }\n  \n  static fromString(value: string): DocumentId {\n    // UUIDバリデーション\n    return new DocumentId(value);\n  }\n  \n  toString(): string {\n    return this.value;\n  }\n}\n\nclass DocumentPath {\n  // 既存実装を修正\n}\n```\n\n## アプリケーションレイヤー\n\n### ユースケース\n\n```typescript\n// 例: ドキュメント読み取りユースケース\ninterface ReadDocumentInput {\n  documentId?: string;\n  path?: string;\n}\n\ninterface ReadDocumentOutput {\n  document: JsonDocument;\n}\n\nclass ReadDocumentUseCase implements IUseCase<ReadDocumentInput, ReadDocumentOutput> {\n  constructor(\n    private readonly documentRepository: IMemoryDocumentRepository\n  ) {}\n  \n  async execute(input: ReadDocumentInput): Promise<ReadDocumentOutput> {\n    // IDまたはパスでの検索ロジック\n    // ..\n  }\n}\n```\n\n### コンバーター\n\nJSONからMarkdownへの一方向変換機能は維持し、表示用途に限定使用します：\n\n```typescript\nclass JsonToMarkdownConverter {\n  static convert(document: JsonDocument): string {\n    // ドキュメントタイプに基づく変換ロジック\n    // ..\n  }\n  \n  private static convertBranchContext(document: JsonDocument): string { /* .. */ }\n  private static convertActiveContext(document: JsonDocument): string { /* .. */ }\n  private static convertProgress(document: JsonDocument): string { /* .. */ }\n  private static convertSystemPatterns(document: JsonDocument): string { /* .. */ }\n}\n```\n\n## インターフェースレイヤー\n\n### CLI コマンド\n\n```typescript\n// 例: JSONドキュメント作成コマンド\nclass CreateJsonDocumentCommand {\n  static register(program: Command): void {\n    program\n      .command('create')\n      .description('Create a new JSON document')\n      .option('-t, --type <type>', 'Document type')\n      .option('-p, --path <path>', 'Document path')\n      .option('--tags <tags>', 'Comma-separated tags')\n      .action(async (options) => {\n        // コマンド実行ロジック\n        // ..\n      });\n  }\n}\n```\n\n### 対話型エディタ\n\n```typescript\nclass JsonDocumentEditor {\n  static async edit(document: JsonDocument): Promise<JsonDocument> {\n    // ドキュメントを一時ファイルに保存\n    // ユーザーの好みのエディタでの編集を許可\n    // 編集後のJSONを検証\n    // 新しいドキュメントインスタンスを返す\n  }\n}\n```\n\n## マイグレーション\n\n### マイグレーションスクリプト\n\n```typescript\nclass MarkdownToJsonMigrator {\n  constructor(\n    private readonly sourceDir: string,\n    private readonly targetDir: string,\n    private readonly logger: ILogger\n  ) {}\n  \n  async migrate(): Promise<MigrationResult> {\n    // 1. すべてのMarkdownファイルをスキャン\n    // 2. ファイルタイプに基づいて適切なコンバーターを選択\n    // 3. JSONに変換\n    // 4. バリデーション\n    // 5. 新しい場所に保存\n    // 6. インデックスを更新\n    // 7. 結果を返す\n  }\n  \n  private async migrateFile(filePath: string): Promise<boolean> {\n    // 個別ファイルマイグレーションロジック\n  }\n  \n  private determineDocumentType(filePath: string, content: string): string {\n    // ファイル名とコンテンツに基づくドキュメントタイプの特定\n  }\n}\n```\n\n### バリデーションと検証\n\n```typescript\nclass MigrationValidator {\n  static validate(originalMarkdown: string, convertedJson: JsonDocument): ValidationResult {\n    // 1. JSONスキーマ検証\n    // 2. 必須フィールドの確認\n    // 3. コンテンツの整合性チェック\n    // 4. タグの検証\n  }\n  \n  static compare(originalMarkdown: string, convertedJson: JsonDocument): ComparisonResult {\n    // マークダウンとJSONの内容比較\n    // 情報損失の特定\n  }\n}\n```\n\n## バックアップとロールバック\n\n```typescript\nclass MigrationBackup {\n  static async backup(sourceDir: string, backupDir: string): Promise<void> {\n    // ファイルシステムバックアップの作成\n  }\n  \n  static async restore(backupDir: string, targetDir: string): Promise<void> {\n    // バックアップからの復元\n  }\n}\n```\n\n## テスト戦略\n\n### ユニットテスト\n\n各コンポーネントの分離テスト：\n\n1. JsonDocument エンティティのバリデーションとメソッド\n2. リポジトリ実装\n3. ユースケース\n4. コンバーター\n\n### 統合テスト\n\n1. ファイルシステム操作を含むエンドツーエンドのフロー\n2. インデックス生成と検索\n3. CLIコマンド実行\n\n### マイグレーションテスト\n\n1. 代表的なMarkdownファイルの変換テスト\n2. エッジケースの処理\n3. 大規模変換のパフォーマンステスト\n\n## パフォーマンス最適化\n\n1. インデックスによる高速検索\n2. 効率的なファイルアクセスパターン\n3. キャッシング戦略\n4. 大規模メモリバンクでの動作検証\n\n## セキュリティ考慮事項\n\n1. 入力検証\n2. ファイルシステムアクセス制限\n3. パスのサニタイズ\n4. エラーメッセージでの情報漏洩防止\n\n## デプロイメント戦略\n\n1. フラグによる段階的ロールアウト\n2. バージョンチェック\n3. 自動バックアップ\n4. アップグレードガイド\n\n## 今後の展望\n\n1. SurrealDB への移行パス\n2. リアルタイム協調編集\n3. REST/GraphQL API\n4. Web UI の構築\n5. プラグイン拡張アーキテクチャ\n",
    "sections": {
      "": "1. SurrealDB への移行パス\n2. リアルタイム協調編集\n3. REST/GraphQL API\n4. Web UI の構築\n5. プラグイン拡張アーキテクチャ"
    }
  }
}
