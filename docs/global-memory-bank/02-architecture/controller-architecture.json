{
  "schema": "memory_document_v1",
  "metadata": {
    "title": "controller-architecture.json",
    "documentType": "generic",
    "path": "02-architecture/controller-architecture.json",
    "tags": [],
    "lastModified": "2025-03-27T17:29:38.177Z"
  },
  "content": {
    "text": "{\\n  \\\"schema\\\": \\\"memory_document_v2\\\",\\n  \\\"metadata\\\": {\\n    \\\"id\\\": \\\"controller-architecture\\\",\\n    \\\"title\\\": \\\"コントローラーアーキテクチャ\\\",\\n    \\\"documentType\\\": \\\"architecture\\\",\\n    \\\"path\\\": \\\"02-architecture/controller-architecture.json\\\",\\n    \\\"tags\\\": [\\n      \\\"architecture\\\",\\n      \\\"controller\\\",\\n      \\\"interface-layer\\\",\\n      \\\"design\\\",\\n      \\\"mcp-package\\\"\\n    ],\\n    \\\"lastModified\\\": \\\"2025-03-28T11:45:00.000Z\\\",\\n    \\\"createdAt\\\": \\\"2025-03-28T11:45:00.000Z\\\",\\n    \\\"version\\\": 1\\n  },\\n  \\\"content\\\": {\\n    \\\"sections\\\": [\\n      {\\n        \\\"title\\\": \\\"概要\\\",\\n        \\\"content\\\": \\\"このドキュメントはMemory Bank MCPサーバーのコントローラーアーキテクチャについて説明します。クリーンアーキテクチャに基づき、インターフェース層のコントローラーの設計と実装について詳細を提供します。\\\"\\n      },\\n      {\\n        \\\"title\\\": \\\"コントローラーの役割\\\",\\n        \\\"content\\\": \\\"コントローラーはインターフェース層に位置し、以下の責務を持ちます：\\\\n\\\\n1. 外部からのリクエストを受け取り、適切なユースケースにルーティングする\\\\n2. リクエストパラメータの基本的な検証を行う\\\\n3. ユースケースの実行結果をプレゼンターを通じて適切な形式に変換する\\\\n4. エラーハンドリングを行い、一貫したエラーレスポンスを提供する\\\\n\\\\nコントローラーはアプリケーション層に依存し、ドメイン層の業務ロジックを直接呼び出すことはありません。\\\"\\n      },\\n      {\\n        \\\"title\\\": \\\"コントローラー階層\\\",\\n        \\\"sections\\\": [\\n          {\\n            \\\"title\\\": \\\"ベースインターフェース\\\",\\n            \\\"content\\\": \\\"すべてのコントローラーは`IController`インターフェースを実装します。これは単なるマーカーインターフェースで、コントローラーであることを示すために使用されます。\\\",\\n            \\\"code\\\": \\\"export interface IController {\\\\n  // マーカーインターフェース\\\\n  readonly _type: 'controller';\\\\n}\\\",\\n            \\\"language\\\": \\\"typescript\\\"\\n          },\\n          {\\n            \\\"title\\\": \\\"専用コントローラーインターフェース\\\",\\n            \\\"content\\\": \\\"各機能ドメインに特化したコントローラーインターフェースが定義されています：\\\",\\n            \\\"interfaces\\\": [\\n              {\\n                \\\"name\\\": \\\"IBranchController\\\",\\n                \\\"description\\\": \\\"ブランチメモリバンク操作のためのコントローラーインターフェース\\\",\\n                \\\"methods\\\": [\\n                  \\\"readDocument\\\",\\n                  \\\"writeDocument\\\",\\n                  \\\"readCoreFiles\\\",\\n                  \\\"writeCoreFiles\\\",\\n                  \\\"getRecentBranches\\\",\\n                  \\\"findDocumentsByTags\\\",\\n                  \\\"updateTagsIndex\\\",\\n                  \\\"readJsonDocument\\\",\\n                  \\\"writeJsonDocument\\\",\\n                  \\\"deleteJsonDocument\\\",\\n                  \\\"listJsonDocuments\\\",\\n                  \\\"searchJsonDocuments\\\",\\n                  \\\"updateJsonIndex\\\"\\n                ]\\n              },\\n              {\\n                \\\"name\\\": \\\"IGlobalController\\\",\\n                \\\"description\\\": \\\"グローバルメモリバンク操作のためのコントローラーインターフェース\\\",\\n                \\\"methods\\\": [\\n                  \\\"readDocument\\\",\\n                  \\\"writeDocument\\\",\\n                  \\\"findDocumentsByTags\\\",\\n                  \\\"updateTagsIndex\\\"\\n                ]\\n              },\\n              {\\n                \\\"name\\\": \\\"IContextController\\\",\\n                \\\"description\\\": \\\"コンテキスト情報（ルール、ブランチ/グローバルメモリバンク）を取得するためのコントローラーインターフェース\\\",\\n                \\\"methods\\\": [\\n                  \\\"readRules\\\",\\n                  \\\"readContext\\\"\\n                ]\\n              },\\n              {\\n                \\\"name\\\": \\\"ITemplateController\\\",\\n                \\\"description\\\": \\\"テンプレート操作のためのコントローラーインターフェース\\\",\\n                \\\"methods\\\": [\\n                  \\\"getTemplate\\\",\\n                  \\\"getTemplateAsMarkdown\\\",\\n                  \\\"createTemplate\\\",\\n                  \\\"updateTemplate\\\",\\n                  \\\"addOrUpdateSection\\\",\\n                  \\\"removeSection\\\",\\n                  \\\"getTemplatesByType\\\",\\n                  \\\"getAllTemplateIds\\\",\\n                  \\\"getAllTemplateTypes\\\"\\n                ]\\n              }\\n            ]\\n          },\\n          {\\n            \\\"title\\\": \\\"コントローラー実装\\\",\\n            \\\"content\\\": \\\"各インターフェースに対する具体的な実装クラスが提供されています：\\\",\\n            \\\"implementations\\\": [\\n              {\\n                \\\"name\\\": \\\"BranchController\\\",\\n                \\\"interface\\\": \\\"IBranchController\\\",\\n                \\\"description\\\": \\\"ブランチメモリバンク操作の主要実装。すべてのブランチ関連操作をサポートする。\\\"\\n              },\\n              {\\n                \\\"name\\\": \\\"JsonBranchController\\\",\\n                \\\"interface\\\": \\\"部分的なIBranchController（JSON操作のメソッドのみ）\\\",\\n                \\\"description\\\": \\\"JSON形式のドキュメント操作に特化したコントローラー。非JSONメソッドは実装しない。\\\"\\n              },\\n              {\\n                \\\"name\\\": \\\"GlobalController\\\",\\n                \\\"interface\\\": \\\"IGlobalController\\\",\\n                \\\"description\\\": \\\"グローバルメモリバンク操作の実装。\\\"\\n              },\\n              {\\n                \\\"name\\\": \\\"ContextController\\\",\\n                \\\"interface\\\": \\\"IContextController\\\",\\n                \\\"description\\\": \\\"ルールやコンテキスト情報の取得を担当する実装。\\\"\\n              },\\n              {\\n                \\\"name\\\": \\\"TemplateController\\\",\\n                \\\"interface\\\": \\\"ITemplateController\\\",\\n                \\\"description\\\": \\\"テンプレート操作の実装。\\\"\\n              }\\n            ]\\n          }\\n        ]\\n      },\\n      {\\n        \\\"title\\\": \\\"レスポンスプレゼンテーション\\\",\\n        \\\"sections\\\": [\\n          {\\n            \\\"title\\\": \\\"MCPResponsePresenter\\\",\\n            \\\"content\\\": \\\"すべてのコントローラーはMCPResponsePresenterを使用して結果をフォーマットします。これにより、統一されたレスポンス形式が保証されます。\\\",\\n            \\\"code\\\": \\\"export interface MCPResponsePresenter {\\\\n  present<T>(data: T): MCPResponse<T>;\\\\n  presentError(error: BaseError | Error): MCPResponse;\\\\n}\\\",\\n            \\\"language\\\": \\\"typescript\\\"\\n          },\\n          {\\n            \\\"title\\\": \\\"MCPResponse型\\\",\\n            \\\"content\\\": \\\"すべてのコントローラーメソッドは統一されたMCPResponse型を返します：\\\",\\n            \\\"code\\\": \\\"export type MCPResponse<T = any> = MCPSuccessResponse<T> | MCPErrorResponse;\\\\n\\\\nexport interface MCPSuccessResponse<T = any> extends MCPBaseResponse {\\\\n  success: true;\\\\n  data: T;\\\\n  meta?: {\\\\n    format?: string;\\\\n    timestamp?: string;\\\\n    version?: string;\\\\n    [key: string]: any;\\\\n  };\\\\n}\\\\n\\\\nexport interface MCPErrorResponse extends MCPBaseResponse {\\\\n  success: false;\\\\n  error: {\\\\n    code: string;\\\\n    message: string;\\\\n    details?: any;\\\\n    status?: number;\\\\n  };\\\\n  meta?: {\\\\n    format?: string;\\\\n    timestamp?: string;\\\\n    version?: string;\\\\n    [key: string]: any;\\\\n  };\\\\n}\\\",\\n            \\\"language\\\": \\\"typescript\\\"\\n          }\\n        ]\\n      },\\n      {\\n        \\\"title\\\": \\\"エラーハンドリング\\\",\\n        \\\"content\\\": \\\"コントローラーは、発生したエラーを適切に捕捉し、統一されたエラーレスポンスに変換します。すべてのコントローラーは内部的にhandleErrorメソッドを持ち、以下のエラータイプを処理します：\\\\n\\\\n1. DomainError: ドメインルール違反や検証エラーなど\\\\n2. ApplicationError: ユースケース実行時のエラー\\\\n3. InfrastructureError: ファイルシステムやネットワークの問題など\\\\n\\\\nこれらのエラーはすべてBaseErrorを継承しており、code、message、detailsプロパティを持ちます。未知のエラーは、DomainErrorでラップされ、UNEXPECTED_ERRORコードが設定されます。\\\"\\n      },\\n      {\\n        \\\"title\\\": \\\"ビルドエラーとマイグレーション\\\",\\n        \\\"content\\\": \\\"モノレポ構造への移行に伴い、コントローラーの実装も@memory-bank/mcpパッケージに移行されました。この過程で、以下の改善が行われました：\\\\n\\\\n1. 非推奨エラー型（BaseError、ApplicationError、InfrastructureError）をDomainErrorに統一\\\\n2. インターフェース定義の明確化と一貫性の向上\\\\n3. コメントとドキュメンテーションの充実\\\\n4. エラーハンドリングの強化\\\\n5. スキーマパッケージへの依存関係の適切な設定\\\\n\\\\n現在すべてのコントローラーは新しいパッケージ構造でビルドできる状態になっています。\\\"\\n      },\\n      {\\n        \\\"title\\\": \\\"依存関係と注入\\\",\\n        \\\"content\\\": \\\"コントローラーはすべて依存性注入パターンに従って設計されています。必要なユースケースやサービスはコンストラクタで注入され、テスト時にはモックに置き換えることができます。\\\\n\\\\n各コントローラーは特定のユースケースに依存しており、下位レイヤーの変更がコントローラーに影響しないよう設計されています。例えば、BranchControllerはReadBranchDocumentUseCase、WriteBranchDocumentUseCaseなどに依存し、これらのユースケースがドメインロジックを実装します。\\\"\\n      },\\n      {\\n        \\\"title\\\": \\\"将来の方向性\\\",\\n        \\\"sections\\\": [\\n          {\\n            \\\"title\\\": \\\"RESTfulインターフェース\\\",\\n            \\\"content\\\": \\\"現在のコントローラーは、将来的にRESTful APIをサポートする方向に発展する可能性があります。すべてのコントローラーメソッドはすでにPromiseベースの非同期インターフェースを持っており、HTTP APIへの移行が容易になっています。\\\"\\n          },\\n          {\\n            \\\"title\\\": \\\"オブザーバーパターン\\\",\\n            \\\"content\\\": \\\"将来的に、変更通知のためにオブザーバーパターンを導入する可能性があります。これにより、メモリバンクのリアルタイム更新や変更通知機能が実装できます。\\\"\\n          },\\n          {\\n            \\\"title\\\": \\\"キャッシング戦略\\\",\\n            \\\"content\\\": \\\"頻繁にアクセスされるデータのパフォーマンス向上のため、コントローラーレベルでのキャッシング戦略の導入を検討中です。\\\"\\n          }\\n        ]\\n      }\\n    ]\\n  }\\n}"
  }
}