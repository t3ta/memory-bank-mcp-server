{
  "schema": "memory_document_v2",
  "metadata": {
    "id": "d7ca88d8-814d-4ce5-9111-fa084d848538",
    "title": "Coding Standards",
    "documentType": "generic",
    "path": "coding-standards.md",
    "tags": [
      "best-practices",
      "typescript",
      "clean-code"
    ],
    "lastModified": "2025-03-21T07:21:59.893Z",
    "createdAt": "2025-03-17T02:13:31.718Z",
    "version": 1
  },
  "content": {
    "general_guidelines": "1. **Follow Clean Architecture**: Respect the separation of concerns between layers:\nDomain layer should have no external dependencies\nApplication layer depends only on Domain layer\nInfrastructure and Interface layers depend on inner layers\n2. **File Structure**:\nOne class/interface per file\nFile name should match the class/interface name\nUse PascalCase for class/interface file names\nUse camelCase for utility/module file names\n3. **Module Organization**:\nGroup related files in directories\nUse index.ts files for exporting public interfaces\nKeep directory structure aligned with architectural layers\n1. **General**:\nUse descriptive names that reveal intent\nAvoid abbreviations except for widely accepted ones\nBe consistent with naming patterns\n2. **Specific Types**:\n**Classes**: PascalCase, noun or noun phrase (e.g., `MemoryDocument`)\n**Interfaces**: PascalCase, noun or noun phrase, consider prefixing with `I` (e.g., `IRepository`)\n**Methods**: camelCase, verb or verb phrase (e.g., `getDocument`)\n**Variables**: camelCase, noun or noun phrase (e.g., `documentPath`)\n**Constants**: UPPER_SNAKE_CASE for true constants (e.g., `MAX_FILE_SIZE`)\n**Files**: Same as the primary export (e.g., `MemoryDocument.ts`)\n3. **Domain-Specific**:\n**Entities**: PascalCase, noun (e.g., `MemoryDocument`)\n**Value Objects**: PascalCase, descriptive noun (e.g., `DocumentPath`)\n**Use Cases**: PascalCase, verb + noun + \"UseCase\" (e.g., `ReadDocumentUseCase`)\n**DTOs**: PascalCase, noun + \"DTO\" (e.g., `DocumentDTO`)\n**Repositories**: PascalCase, noun + \"Repository\" (e.g., `BranchMemoryBankRepository`)\n1. **Documentation**:\nAll comments in source code need to be in English\nUse JSDoc for classes, interfaces, methods, and non-obvious properties\nInclude parameter and return type descriptions\nDocument exceptions/errors that can be thrown\n2. **Code Comments**:\nComment \"why\", not \"what\" or \"how\"\nKeep comments current with code changes\nUse TODO/FIXME with explanation when necessary\n3. **Example**:```typescript\n/**\n* Finds documents that match the given tags\n*\n* @param branchInfo Branch information\n* @param tags Tags to search for\n* @param matchAll If true, documents must have all tags; if false, any tag is sufficient\n* @returns Promise resolving to array of matching documents\n* @throws {DomainError} If tags are invalid\n*/\nasync findDocumentsByTags(\nbranchInfo: BranchInfo,\nmatchAll: boolean = false\n): Promise<MemoryDocument[]> {\n// Implementation\n}\n```\n",
    "typescriptspecific_guidelines": [
      "1. **Types and Interfaces**:\nPrefer interfaces for public APIs\nUse types for unions, intersections, and mapped types\nDefine shared types in dedicated files\n2. **Avoid Any**:\nMinimize use of `any`\nUse `unknown` when type is not known\nUse proper type guards to narrow types\n3. **Null Handling**:\nUse optional parameters/properties rather than null\nBe explicit about null/undefined handling\nConsider using the Maybe/Option pattern for nullable values\n1. **Generics**:\nUse generics to create reusable components\nProvide clear, descriptive names for type parameters\nConsider constraints when appropriate\n2. **Enums**:\nUse string enums for better debugging and serialization\nDefine enums close to where they are used\n3. **Interfaces vs Types**:\nPrefer `interface` for public APIs and objects with methods\nUse `type` for unions, primitives, tuples, and function types\nBe consistent with your choice\n4. **Advanced Types**:",
      "Leverage mapped types, conditional types, and utility types",
      "Document complex type manipulations"
    ],
    "clean_code_practices": [
      "1. **Single Responsibility**:\nFunctions should do one thing and do it well\nKeep functions small (generally < 20 lines)\nExtract complex logic into helper functions\n2. **Parameter Lists**:\nLimit number of parameters (â‰¤ 3 is ideal)\nUse object parameters for multiple optional parameters\nConsider function overloading for different parameter sets\n3. **Error Handling**:\nUse typed errors when possible\nProvide meaningful error messages\nDocument error conditions\n1. **Design**:\nFollow the Single Responsibility Principle\nKeep classes focused and cohesive\nPrefer composition over inheritance\n2. **Organization**:\nGroup related methods together\nPublic methods first, then protected, then private\nProperties first, then constructor, then methods\n3. **Encapsulation**:",
      "Make fields private when appropriate",
      "Provide accessor methods when needed",
      "Use readonly for immutable properties"
    ],
    "architecturespecific_guidelines": [
      "1. **Entities**:\nMake entities rich with business logic\nImplement validation logic within entities\nUse factory methods for complex object creation\n2. **Value Objects**:\nMake value objects immutable\nImplement equality based on properties\nValidate values in constructor\n3. **Repository Interfaces**:\nDefine clear, domain-oriented methods\nAvoid leaking implementation details\nUse domain entities as input/output types\n1. **Use Cases**:\nOne class per use case\nImplement the `IUseCase` interface\nClearly define input/output DTOs\nHandle errors and validation\n2. **DTOs**:\nKeep DTOs simple and focused on data transfer\nUse meaningful property names\nInclude JSDoc comments for properties\nUse appropriate TypeScript types\n1. **Repository Implementations**:\nImplement domain repository interfaces\nHandle data mapping and persistence concerns\nIsolate external dependencies\n2. **External Services**:\nWrap external dependencies in service classes\nImplement domain interfaces\nHandle errors and translate to domain errors\n1. **Controllers**:\nFocus on request handling and delegation\nValidate input before passing to use cases\nMap application errors to appropriate responses\n2. **Presenters**:",
      "Transform application output to response format",
      "Handle formatting and localization concerns",
      "Keep presenters focused and simple"
    ],
    "testing_guidelines": [
      "1. **Unit Tests**:\nTest domain layer thoroughly\nMock dependencies for isolated testing\nFocus on behavior, not implementation details\n2. **Integration Tests**:\nTest across architectural boundaries\nUse real implementations for key components\nFocus on component interaction\n3. **Test Organization**:",
      "Mirror source code structure",
      "Use descriptive test names",
      "Follow Arrange-Act-Assert pattern"
    ],
    "code_examples": "```typescript\nexport class MemoryDocument {\nprivate readonly props: MemoryDocumentProps;\nprivate constructor(props: MemoryDocumentProps) {\nthis.props = props;\n}\npublic static create(props: MemoryDocumentProps): MemoryDocument {\n// Validation logic\nif (!props.path || !props.content) {\nthrow new DomainError(\nDomainErrorCodes.INVALID_ENTITY,\n'Memory document must have a path and content'\n);\n}\nreturn new MemoryDocument(props);\n}\npublic get path(): DocumentPath {\nreturn this.props.path;\n}\npublic get content(): string {\nreturn this.props.content;\n}\npublic get tags(): Tag[] {\nreturn [..this.props.tags]; // Return copy to maintain immutability\n}\npublic get lastModified(): Date {\nreturn new Date(this.props.lastModified);\n}\n// Business logic\npublic hasTag(tag: Tag): boolean {\nreturn this.props.tags.some(t => t.equals(tag));\n}\npublic addTag(tag: Tag): MemoryDocument {\nif (this.hasTag(tag)) {\nreturn this;\n}\nreturn new MemoryDocument({\n..this.props,\nlastModified: new Date()\n});\n}\npublic updateContent(content: string): MemoryDocument {\nif (content === this.props.content) {\nreturn this;\n}\nreturn new MemoryDocument({\n..this.props,\ncontent,\nlastModified: new Date()\n});\n}\n}\n```\n```typescript\nexport class ReadBranchDocumentUseCase implements IUseCase<ReadBranchDocumentInput, ReadBranchDocumentOutput> {\nconstructor(\nprivate readonly branchRepository: IBranchMemoryBankRepository\n) {}\nasync execute(input: ReadBranchDocumentInput): Promise<ReadBranchDocumentOutput> {\ntry {\n// Validate input\nif (!input.branchName) {\nthrow new ApplicationError(\nApplicationErrorCodes.INVALID_INPUT,\n'Branch name is required'\n);\n}\nif (!input.path) {\nthrow new ApplicationError(\nApplicationErrorCodes.INVALID_INPUT,\n'Document path is required'\n);\n}\n// Create domain objects\nconst branchInfo = BranchInfo.create(input.branchName);\nconst documentPath = DocumentPath.create(input.path);\n// Check if branch exists\nconst branchExists = await this.branchRepository.exists(input.branchName);\nif (!branchExists) {\nthrow new DomainError(\nDomainErrorCodes.BRANCH_NOT_FOUND,\n`Branch \"${input.branchName}\" not found`\n);\n}\n// Get document from repository\nconst document = await this.branchRepository.getDocument(branchInfo, documentPath);\n// Check if document exists\nif (!document) {\nthrow new DomainError(\nDomainErrorCodes.DOCUMENT_NOT_FOUND,\n`Document \"${input.path}\" not found in branch \"${input.branchName}\"`\n);\n}\n// Transform to DTO\nreturn {\ndocument: {\npath: document.path.value,\ncontent: document.content,\nlastModified: document.lastModified.toISOString()\n}\n};\n} catch (error) {\n// Re-throw domain and application errors\nif (error instanceof DomainError || error instanceof ApplicationError) {\nthrow error;\n}\n// Wrap other errors\nthrow new ApplicationError(\nApplicationErrorCodes.USE_CASE_EXECUTION_FAILED,\n`Failed to read document: ${(error as Error).message}`,\n{ originalError: error }\n);\n}\n}\n}\n```\n```typescript\nexport class BranchController implements IBranchController {\nconstructor(\nprivate readonly readBranchDocumentUseCase: ReadBranchDocumentUseCase,\nprivate readonly writeBranchDocumentUseCase: WriteBranchDocumentUseCase,\nprivate readonly presenter: MCPResponsePresenter\n) {}\nasync readDocument(branchName: string, path: string): Promise<MCPResponse<DocumentDTO>> {\ntry {\nlogger.info(`Reading document from branch ${branchName}: ${path}`);\nconst result = await this.readBranchDocumentUseCase.execute({\nbranchName,\npath\n});\nreturn this.presenter.present(result.document);\n} catch (error) {\nreturn this.handleError(error);\n}\n}\nprivate handleError(error: any): MCPResponse {\nif (error instanceof DomainError ||\nerror instanceof ApplicationError ||\nerror instanceof InfrastructureError) {\nreturn this.presenter.presentError(error);\n}\n// Unknown error\nreturn this.presenter.presentError(\nnew ApplicationError(\n'UNEXPECTED_ERROR',\nerror instanceof Error ? error.message : 'An unexpected error occurred',\n{ originalError: error }\n)\n);\n}\n}\n```"
  }
}
